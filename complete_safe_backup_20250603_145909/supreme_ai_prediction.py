#!/usr/bin/env python3)
# -*- coding: utf-8 -*-)
""")
HANAZONOã‚·ã‚¹ãƒ†ãƒ  ä¸–ç•Œæœ€é«˜ãƒ¬ãƒ™ãƒ«AIäºˆæ¸¬ã‚¨ãƒ³ã‚¸ãƒ³ v1.0)
6å¹´é–“ã®æ­´å²ãƒ‡ãƒ¼ã‚¿ã‚’æ´»ç”¨ã—ãŸè¶…é«˜ç²¾åº¦äºˆæ¸¬ã‚·ã‚¹ãƒ†ãƒ )
)
Prediction Features:)
1. ğŸ”® Daily Usage Prediction (æ—¥åˆ¥ä½¿ç”¨é‡äºˆæ¸¬))
2. ğŸ“Š Monthly Battle Prediction (æœˆæ¬¡ãƒãƒˆãƒ«çµæœäºˆæ¸¬))
3. âš¡ Optimization Recommendation (æœ€é©åŒ–ææ¡ˆ))
4. ğŸ¯ ROI Prediction (æŠ•è³‡å›åäºˆæ¸¬))
5. ğŸŒŸ Seasonal Pattern Learning (å­£ç¯€ãƒ‘ã‚¿ãƒ¼ãƒ³å­¦ç¿’))
""")
)
import numpy as np)
import pandas as pd)
import sqlite3)
from datetime import datetime, timedelta)
from typing import Dict, List, Optional, Tuple)
import json)
import logging)
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor)
from sklearn.preprocessing import StandardScaler)
from sklearn.model_selection import train_test_split)
from sklearn.metrics import mean_absolute_error, r2_score)
)
class SupremeAIPrediction:)
    """ä¸–ç•Œæœ€é«˜ãƒ¬ãƒ™ãƒ«AIäºˆæ¸¬ã‚¨ãƒ³ã‚¸ãƒ³""")
    )
    def __init__(self, db_path="data/comprehensive_electric_data.db"):)
        self.db_path = db_path)
        self.logger = self.setup_logger())
        )
        # æ©Ÿæ¢°å­¦ç¿’ãƒ¢ãƒ‡ãƒ«)
        self.daily_model = None)
        self.monthly_model = None)
        self.scaler = StandardScaler())
        )
        # å¤©æ°—ã‚³ãƒ¼ãƒ‰å¤‰æ›)
        self.weather_codes = {)
            "å¿«æ™´": 0, "æ™´ã‚Œ": 1, "æ›‡ã‚Š": 2, "ã«ã‚ã‹é›¨": 3, "é›¨": 4, )
            "é›·": 5, "é›¨å¼·ã—": 6, "ã¿ãã‚Œ": 7, "é›ª": 8)
        })
        )
        # å­£ç¯€ãƒ‘ã‚¿ãƒ¼ãƒ³)
        self.seasonal_patterns = {})
        )
        # HANAZONOã‚·ã‚¹ãƒ†ãƒ è¨­å®šåŠ¹æœ)
        self.hanazono_settings_effect = {)
            "æ˜¥ç§‹å­£": {"charge_current": 50, "charge_time": 45, "output_soc": 45, "efficiency": 0.85},)
            "å¤å­£": {"charge_current": 35, "charge_time": 30, "output_soc": 35, "efficiency": 0.90},)
            "å†¬å­£": {"charge_current": 60, "charge_time": 60, "output_soc": 60, "efficiency": 0.80})
        })
    )
    def setup_logger(self):)
        """ãƒ­ã‚¬ãƒ¼è¨­å®š""")
        logger = logging.getLogger('SupremeAIPrediction'))
        logger.setLevel(logging.INFO))
        )
        if not logger.handlers:)
            handler = logging.FileHandler('logs/ai_prediction.log'))
            formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
            handler.setFormatter(formatter))
            logger.addHandler(handler))
        )
        return logger)
    )
    def load_training_data(self) -> pd.DataFrame:)
        """è¨“ç·´ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿""")
        with sqlite3.connect(self.db_path) as conn:)
            # æ—¥åˆ¥ãƒ‡ãƒ¼ã‚¿ã¨æœˆåˆ¥ãƒ‡ãƒ¼ã‚¿ã‚’çµåˆ)
            query = ''')
                SELECT d.date, d.usage_kwh, d.weather, d.sunshine_hours,)
                       d.temp_high, d.temp_low, d.weekday, d.phase,)
                       m.cost_yen, m.daytime_kwh, m.nighttime_kwh)
                FROM comprehensive_daily d)
                LEFT JOIN comprehensive_monthly m )
                    ON d.year = m.year AND d.month = m.month)
                WHERE d.usage_kwh > 0)
                ORDER BY d.date)
            ''')
            df = pd.read_sql_query(query, conn))
        )
        if df.empty:)
            self.logger.warning("è¨“ç·´ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"))
            return pd.DataFrame())
        )
        # ç‰¹å¾´é‡ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°)
        df = self.engineer_features(df))
        )
        self.logger.info(f"è¨“ç·´ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å®Œäº†: {len(df)}æ—¥åˆ†"))
        return df)
    )
    def engineer_features(self, df: pd.DataFrame) -> pd.DataFrame:)
        """ç‰¹å¾´é‡ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ãƒªãƒ³ã‚°""")
        # æ—¥ä»˜ç‰¹å¾´é‡)
        df['date'] = pd.to_datetime(df['date']))
        df['day_of_year'] = df['date'].dt.dayofyear)
        df['month'] = df['date'].dt.month)
        df['season'] = df['month'].apply(self.get_season))
        df['is_weekend'] = df['weekday'].isin(['åœŸ', 'æ—¥']).astype(int))
        )
        # å¤©æ°—ç‰¹å¾´é‡)
        df['weather_code'] = df['weather'].map(self.weather_codes).fillna(2)  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ›‡ã‚Š)
        )
        # æ°—æ¸©ç‰¹å¾´é‡)
        df['temp_avg'] = (df['temp_high'] + df['temp_low']) / 2)
        df['temp_range'] = df['temp_high'] - df['temp_low'])
        )
        # å†·æš–æˆ¿éœ€è¦äºˆæ¸¬)
        df['cooling_demand'] = np.maximum(df['temp_high'] - 25, 0)  # 25åº¦ä»¥ä¸Šã§å†·æˆ¿éœ€è¦)
        df['heating_demand'] = np.maximum(18 - df['temp_low'], 0)   # 18åº¦ä»¥ä¸‹ã§æš–æˆ¿éœ€è¦)
        )
        # ãƒ•ã‚§ãƒ¼ã‚ºç‰¹å¾´é‡)
        phase_mapping = {"baseline": 0, "covid": 1, "price_hike": 2, "pre_hanazono": 3, "hanazono": 4})
        df['phase_code'] = df['phase'].map(phase_mapping))
        )
        # ç§»å‹•å¹³å‡ç‰¹å¾´é‡ï¼ˆéå»3æ—¥ã€7æ—¥ï¼‰)
        df['usage_ma3'] = df['usage_kwh'].rolling(window=3, min_periods=1).mean())
        df['usage_ma7'] = df['usage_kwh'].rolling(window=7, min_periods=1).mean())
        df['temp_ma3'] = df['temp_avg'].rolling(window=3, min_periods=1).mean())
        )
        # ãƒ©ã‚°ç‰¹å¾´é‡ï¼ˆå‰æ—¥ã€å‰é€±åŒæ›œæ—¥ï¼‰)
        df['usage_lag1'] = df['usage_kwh'].shift(1))
        df['usage_lag7'] = df['usage_kwh'].shift(7))
        )
        # æ¬ æå€¤è£œå®Œ)
        df = df.fillna(method='ffill').fillna(method='bfill'))
        )
        return df)
    )
    def get_season(self, month: int) -> str:)
        """å­£ç¯€åˆ¤å®š""")
        if month in [12, 1, 2, 3]:)
            return "å†¬å­£")
        elif month in [4, 5, 6, 10, 11]:)
            return "æ˜¥ç§‹å­£")
        else:  # 7, 8, 9)
            return "å¤å­£")
    )
    def train_models(self):)
        """æ©Ÿæ¢°å­¦ç¿’ãƒ¢ãƒ‡ãƒ«ã®è¨“ç·´""")
        df = self.load_training_data())
        )
        if df.empty:)
            self.logger.error("è¨“ç·´ãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³ã—ã¦ã„ã¾ã™"))
            return)
        )
        # ç‰¹å¾´é‡é¸æŠ)
        feature_columns = [)
            'day_of_year', 'month', 'is_weekend', 'weather_code',)
            'temp_high', 'temp_low', 'temp_avg', 'temp_range',)
            'sunshine_hours', 'cooling_demand', 'heating_demand',)
            'phase_code', 'usage_ma3', 'usage_ma7', 'temp_ma3',)
            'usage_lag1', 'usage_lag7')
        ])
        )
        # ç‰¹å¾´é‡ã¨ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’åˆ†é›¢)
        X = df[feature_columns].dropna())
        y = df.loc[X.index, 'usage_kwh'])
        )
        # æ­£è¦åŒ–)
        X_scaled = self.scaler.fit_transform(X))
        )
        # è¨“ç·´ãƒ»ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿åˆ†å‰²)
        X_train, X_test, y_train, y_test = train_test_split()
            X_scaled, y, test_size=0.2, random_state=42, shuffle=False)
        ))
        )
        # æ—¥åˆ¥äºˆæ¸¬ãƒ¢ãƒ‡ãƒ«è¨“ç·´ï¼ˆRandom Forest + Gradient Boostingï¼‰)
        self.daily_model = {)
            'rf': RandomForestRegressor(n_estimators=100, random_state=42),)
            'gbr': GradientBoostingRegressor(n_estimators=100, random_state=42))
        })
        )
        for name, model in self.daily_model.items():)
            model.fit(X_train, y_train))
            y_pred = model.predict(X_test))
            mae = mean_absolute_error(y_test, y_pred))
            r2 = r2_score(y_test, y_pred))
            )
            self.logger.info(f"{name}ãƒ¢ãƒ‡ãƒ«æ€§èƒ½: MAE={mae:.2f}, RÂ²={r2:.3f}"))
        )
        # ç‰¹å¾´é‡é‡è¦åº¦ã‚’è¨˜éŒ²)
        feature_importance = list(zip(feature_columns, )
                                    self.daily_model['rf'].feature_importances_)))
        feature_importance.sort(key=lambda x: x[1], reverse=True))
        )
        self.logger.info("é‡è¦ç‰¹å¾´é‡ãƒˆãƒƒãƒ—5:"))
        for feature, importance in feature_importance[:5]:)
            self.logger.info(f"  {feature}: {importance:.3f}"))
        )
        # å­£ç¯€ãƒ‘ã‚¿ãƒ¼ãƒ³å­¦ç¿’)
        self.learn_seasonal_patterns(df))
        )
        self.logger.info("æ©Ÿæ¢°å­¦ç¿’ãƒ¢ãƒ‡ãƒ«è¨“ç·´å®Œäº†"))
    )
    def learn_seasonal_patterns(self, df: pd.DataFrame):)
        """å­£ç¯€ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å­¦ç¿’""")
        for season in ["æ˜¥ç§‹å­£", "å¤å­£", "å†¬å­£"]:)
            season_data = df[df['season'] == season])
            if not season_data.empty:)
                self.seasonal_patterns[season] = {)
                    "avg_usage": season_data['usage_kwh'].mean(),)
                    "std_usage": season_data['usage_kwh'].std(),)
                    "avg_temp": season_data['temp_avg'].mean(),)
                    "peak_months": season_data.groupby('month')['usage_kwh'].mean().to_dict())
                })
        )
        self.logger.info("å­£ç¯€ãƒ‘ã‚¿ãƒ¼ãƒ³å­¦ç¿’å®Œäº†"))
    )
    def predict_daily_usage(self, date: str, weather: str, temp_high: float, )
                          temp_low: float, sunshine_hours: float = None) -> Dict:)
        """ğŸ”® æ—¥åˆ¥ä½¿ç”¨é‡äºˆæ¸¬""")
        if self.daily_model is None:)
            return {"error": "ãƒ¢ãƒ‡ãƒ«ãŒè¨“ç·´ã•ã‚Œã¦ã„ã¾ã›ã‚“"})
        )
        try:)
            # ç‰¹å¾´é‡ä½œæˆ)
            pred_date = pd.to_datetime(date))
            features = self.create_prediction_features()
                pred_date, weather, temp_high, temp_low, sunshine_hours)
            ))
            )
            # äºˆæ¸¬å®Ÿè¡Œ)
            features_scaled = self.scaler.transform([features]))
            )
            # ã‚¢ãƒ³ã‚µãƒ³ãƒ–ãƒ«äºˆæ¸¬)
            rf_pred = self.daily_model['rf'].predict(features_scaled)[0])
            gbr_pred = self.daily_model['gbr'].predict(features_scaled)[0])
            ensemble_pred = (rf_pred + gbr_pred) / 2)
            )
            # å­£ç¯€è£œæ­£)
            season = self.get_season(pred_date.month))
            if season in self.seasonal_patterns:)
                seasonal_factor = self.seasonal_patterns[season]["avg_usage"] / 25.0  # ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³)
                ensemble_pred *= seasonal_factor)
            )
            # HANAZONOã‚·ã‚¹ãƒ†ãƒ åŠ¹æœé©ç”¨)
            if pred_date >= pd.to_datetime("2024-08-25"):)
                hanazono_effect = self.calculate_hanazono_effect(season, weather, temp_high))
                ensemble_pred *= (1 - hanazono_effect))
            )
            # ä¿¡é ¼åŒºé–“è¨ˆç®—)
            confidence_interval = self.calculate_confidence_interval(ensemble_pred, season))
            )
            return {)
                "predicted_usage": round(ensemble_pred, 2),)
                "confidence_low": round(confidence_interval[0], 2),)
                "confidence_high": round(confidence_interval[1], 2),)
                "season": season,)
                "weather_impact": self.analyze_weather_impact(weather, temp_high, temp_low),)
                "prediction_summary": f"{date}: {ensemble_pred:.1f}kWhäºˆæ¸¬ ({season})")
            })
            )
        except Exception as e:)
            self.logger.error(f"äºˆæ¸¬ã‚¨ãƒ©ãƒ¼: {e}"))
            return {"error": f"äºˆæ¸¬ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}"})
    )
    def create_prediction_features(self, date: pd.Timestamp, weather: str, )
                                 temp_high: float, temp_low: float, )
                                 sunshine_hours: float = None) -> List[float]:)
        """äºˆæ¸¬ç”¨ç‰¹å¾´é‡ä½œæˆ""")
        temp_avg = (temp_high + temp_low) / 2)
        temp_range = temp_high - temp_low)
        )
        # éå»ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ç§»å‹•å¹³å‡ãƒ»ãƒ©ã‚°ç‰¹å¾´é‡ã‚’å–å¾—)
        historical_data = self.get_historical_context(date))
        )
        features = [)
            date.dayofyear,  # day_of_year)
            date.month,      # month)
            1 if date.weekday() >= 5 else 0,  # is_weekend)
            self.weather_codes.get(weather, 2),  # weather_code)
            temp_high,       # temp_high)
            temp_low,        # temp_low)
            temp_avg,        # temp_avg)
            temp_range,      # temp_range)
            sunshine_hours if sunshine_hours else 8.0,  # sunshine_hours (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ8æ™‚é–“))
            max(temp_high - 25, 0),  # cooling_demand)
            max(18 - temp_low, 0),   # heating_demand)
            4 if date >= pd.to_datetime("2024-08-25") else 2,  # phase_code)
            historical_data.get("usage_ma3", 22.0),   # usage_ma3)
            historical_data.get("usage_ma7", 22.0),   # usage_ma7)
            historical_data.get("temp_ma3", temp_avg), # temp_ma3)
            historical_data.get("usage_lag1", 22.0),  # usage_lag1)
            historical_data.get("usage_lag7", 22.0)   # usage_lag7)
        ])
        )
        return features)
    )
    def get_historical_context(self, date: pd.Timestamp) -> Dict:)
        """éå»ãƒ‡ãƒ¼ã‚¿ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆå–å¾—""")
        with sqlite3.connect(self.db_path) as conn:)
            # éå»30æ—¥ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—)
            start_date = (date - timedelta(days=30)).strftime('%Y-%m-%d'))
            end_date = (date - timedelta(days=1)).strftime('%Y-%m-%d'))
            )
            query = ''')
                SELECT usage_kwh, temp_high, temp_low)
                FROM comprehensive_daily)
                WHERE date BETWEEN ? AND ?)
                ORDER BY date DESC)
            ''')
            )
            df = pd.read_sql_query(query, conn, params=(start_date, end_date)))
            )
            if df.empty:)
                return {})
            )
            df['temp_avg'] = (df['temp_high'] + df['temp_low']) / 2)
            )
            return {)
                "usage_ma3": df['usage_kwh'].head(3).mean(),)
                "usage_ma7": df['usage_kwh'].head(7).mean(),)
                "temp_ma3": df['temp_avg'].head(3).mean(),)
                "usage_lag1": df['usage_kwh'].iloc[0] if len(df) > 0 else None,)
                "usage_lag7": df['usage_kwh'].iloc[6] if len(df) > 6 else None)
            })
    )
    def calculate_hanazono_effect(self, season: str, weather: str, temp_high: float) -> float:)
        """HANAZONOã‚·ã‚¹ãƒ†ãƒ åŠ¹æœè¨ˆç®—""")
        base_efficiency = self.hanazono_settings_effect.get(season, {}).get("efficiency", 0.85))
        )
        # å¤©æ°—ã«ã‚ˆã‚‹èª¿æ•´)
        weather_factor = {)
            "å¿«æ™´": 1.2, "æ™´ã‚Œ": 1.1, "æ›‡ã‚Š": 1.0, "ã«ã‚ã‹é›¨": 0.9, "é›¨": 0.8)
        }.get(weather, 1.0))
        )
        # æ°—æ¸©ã«ã‚ˆã‚‹èª¿æ•´ï¼ˆæœ€é©æ¸©åº¦åŸŸã§ã®åŠ¹ç‡å‘ä¸Šï¼‰)
        if 20 <= temp_high <= 30:)
            temp_factor = 1.1)
        elif temp_high > 35 or temp_high < 0:)
            temp_factor = 0.9)
        else:)
            temp_factor = 1.0)
        )
        return min(base_efficiency * weather_factor * temp_factor, 0.95)  # æœ€å¤§95%å‰Šæ¸›)
    )
    def calculate_confidence_interval(self, prediction: float, season: str) -> Tuple[float, float]:)
        """ä¿¡é ¼åŒºé–“è¨ˆç®—""")
        if season in self.seasonal_patterns:)
            std = self.seasonal_patterns[season]["std_usage"])
        else:)
            std = 5.0  # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ¨™æº–åå·®)
        )
        # 95%ä¿¡é ¼åŒºé–“)
        margin = 1.96 * std)
        return (max(prediction - margin, 0), prediction + margin))
    )
    def analyze_weather_impact(self, weather: str, temp_high: float, temp_low: float) -> Dict:)
        """å¤©æ°—å½±éŸ¿åˆ†æ""")
        impact_level = "normal")
        impact_description = "é€šå¸¸ã®ä½¿ç”¨é‡")
        )
        # å†·æš–æˆ¿éœ€è¦åˆ†æ)
        if temp_high > 30:)
            impact_level = "high")
            impact_description = f"çŒ›æš‘æ—¥(æœ€é«˜{temp_high}â„ƒ) - å†·æˆ¿éœ€è¦å¢—åŠ ")
        elif temp_low < 5:)
            impact_level = "high" )
            impact_description = f"å³å¯’æ—¥(æœ€ä½{temp_low}â„ƒ) - æš–æˆ¿éœ€è¦å¢—åŠ ")
        elif weather in ["é›¨", "é›¨å¼·ã—"]:)
            impact_level = "medium")
            impact_description = "é›¨å¤© - åœ¨å®…æ™‚é–“å¢—åŠ ã«ã‚ˆã‚Šä½¿ç”¨é‡ã‚„ã‚„å¢—åŠ ")
        elif weather in ["å¿«æ™´", "æ™´ã‚Œ"]:)
            impact_level = "low")
            impact_description = "æ™´å¤© - å¤–å‡ºå¢—åŠ ã«ã‚ˆã‚Šä½¿ç”¨é‡ã‚„ã‚„æ¸›å°‘")
        )
        return {)
            "impact_level": impact_level,)
            "description": impact_description,)
            "cooling_demand": max(temp_high - 25, 0),)
            "heating_demand": max(18 - temp_low, 0))
        })
    )
    def predict_monthly_battle(self, year: int, month: int) -> Dict:)
        """ğŸ“Š æœˆæ¬¡ãƒãƒˆãƒ«çµæœäºˆæ¸¬""")
        try:)
            # å½“æœˆã®æ—¥ã€…ã®äºˆæ¸¬ã‚’ç©ã¿ä¸Šã’)
            month_start = pd.to_datetime(f"{year}-{month:02d}-01"))
            )
            if month == 12:)
                month_end = pd.to_datetime(f"{year+1}-01-01") - timedelta(days=1))
            else:)
                month_end = pd.to_datetime(f"{year}-{month+1:02d}-01") - timedelta(days=1))
            )
            # ç°¡æ˜“çš„ãªæœˆé–“äºˆæ¸¬ï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯æ—¥ã€…ã®äºˆæ¸¬ã‚’ç©ã¿ä¸Šã’ï¼‰)
            season = self.get_season(month))
            base_usage = self.seasonal_patterns.get(season, {}).get("avg_usage", 25.0))
            )
            # æœˆã®æ—¥æ•°åˆ†ã‚’ç©ç®—)
            days_in_month = (month_end - month_start).days + 1)
            predicted_monthly_usage = base_usage * days_in_month)
            )
            # HANAZONOã‚·ã‚¹ãƒ†ãƒ åŠ¹æœé©ç”¨)
            if year >= 2024 and month >= 8:)
                hanazono_effect = self.calculate_hanazono_effect(season, "æ›‡ã‚Š", 25.0))
                predicted_monthly_usage *= (1 - hanazono_effect))
            )
            # å‰å¹´åŒæœˆã¨ã®æ¯”è¼ƒ)
            previous_year_usage = self.get_historical_monthly_usage(year - 1, month))
            )
            if previous_year_usage:)
                battle_result = "å‹åˆ©" if predicted_monthly_usage < previous_year_usage else "æ•—åŒ—")
                improvement = ((previous_year_usage - predicted_monthly_usage) / previous_year_usage) * 100)
            else:)
                battle_result = "ãƒ‡ãƒ¼ã‚¿ä¸è¶³")
                improvement = 0)
            )
            return {)
                "predicted_usage": round(predicted_monthly_usage, 1),)
                "previous_year_usage": previous_year_usage,)
                "predicted_battle_result": battle_result,)
                "predicted_improvement": round(improvement, 1),)
                "confidence": "high" if abs(improvement) > 10 else "medium",)
                "battle_summary": f"{year}å¹´{month}æœˆäºˆæ¸¬: {improvement:+.1f}% ({battle_result})")
            })
            )
        except Exception as e:)
            self.logger.error(f"æœˆæ¬¡ãƒãƒˆãƒ«äºˆæ¸¬ã‚¨ãƒ©ãƒ¼: {e}"))
            return {"error": f"äºˆæ¸¬ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}"})
    )
    def get_historical_monthly_usage(self, year: int, month: int) -> Optional[float]:)
        """éå»ã®æœˆé–“ä½¿ç”¨é‡å–å¾—""")
        with sqlite3.connect(self.db_path) as conn:)
            cursor = conn.cursor())
            cursor.execute(''')
                SELECT usage_kwh FROM comprehensive_monthly)
                WHERE year = ? AND month = ?)
            ''', (year, month)))
            )
            result = cursor.fetchone())
            return result[0] if result else None)
    )
    def recommend_optimization(self, weather_forecast: List[Dict]) -> Dict:)
        """âš¡ æœ€é©åŒ–ææ¡ˆ""")
        recommendations = [])
        total_savings = 0)
        )
        for day_forecast in weather_forecast[:7]:  # 1é€±é–“åˆ†)
            date = day_forecast["date"])
            weather = day_forecast["weather"])
            temp_high = day_forecast["temp_high"])
            temp_low = day_forecast["temp_low"])
            )
            # ä½¿ç”¨é‡äºˆæ¸¬)
            prediction = self.predict_daily_usage(date, weather, temp_high, temp_low))
            )
            if "error" not in prediction:)
                # æœ€é©è¨­å®šææ¡ˆ)
                season = prediction["season"])
                optimal_settings = self.hanazono_settings_effect.get(season, {}))
                )
                # å¤©æ°—åˆ¥å¾®èª¿æ•´)
                if weather in ["å¿«æ™´", "æ™´ã‚Œ"]:)
                    adjustment = "â˜€ï¸ æ™´å¤©è¨­å®š: å……é›»é›»æµ-10Aï¼ˆç™ºé›»é‡è±Šå¯Œã®ãŸã‚ï¼‰")
                    savings_boost = 0.05)
                elif weather in ["é›¨", "é›¨å¼·ã—"]:)
                    adjustment = "ğŸŒ§ï¸ é›¨å¤©è¨­å®š: å……é›»é›»æµ+10Aï¼ˆç™ºé›»é‡ä¸è¶³ã®ãŸã‚ï¼‰")
                    savings_boost = -0.02)
                else:)
                    adjustment = "â˜ï¸ æ¨™æº–è¨­å®š: æ¨å¥¨è¨­å®šã‚’ç¶­æŒ")
                    savings_boost = 0)
                )
                daily_savings = prediction["predicted_usage"] * savings_boost * 30  # é›»æ°—ä»£æ›ç®—)
                total_savings += daily_savings)
                )
                recommendations.append({)
                    "date": date,)
                    "predicted_usage": prediction["predicted_usage"],)
                    "optimal_settings": optimal_settings,)
                    "adjustment": adjustment,)
                    "estimated_savings": round(daily_savings, 0))
                }))
        )
        return {)
            "weekly_recommendations": recommendations,)
            "total_weekly_savings": round(total_savings, 0),)
            "optimization_summary": f"1é€±é–“ã®æœ€é©åŒ–ã§ç´„Â¥{total_savings:,.0f}ã®è¿½åŠ å‰Šæ¸›å¯èƒ½")
        })
    )
    def predict_roi(self, investment_amount: float, years: int = 10) -> Dict:)
        """ğŸ¯ ROIäºˆæ¸¬""")
        try:)
            # å¹´é–“å‰Šæ¸›é¡ã®äºˆæ¸¬ï¼ˆç¾åœ¨ã®å®Ÿç¸¾ãƒ™ãƒ¼ã‚¹ï¼‰)
            current_annual_savings = 32266  # å®Ÿç¸¾å€¤)
            )
            # å°†æ¥ã®å‰Šæ¸›é¡äºˆæ¸¬ï¼ˆã‚·ã‚¹ãƒ†ãƒ å­¦ç¿’åŠ¹æœè¾¼ã¿ï¼‰)
            future_savings = [])
            for year in range(1, years + 1):)
                # å­¦ç¿’åŠ¹æœã«ã‚ˆã‚‹æ”¹å–„ï¼ˆå¹´2%å‘ä¸Šï¼‰)
                learning_factor = 1 + (0.02 * year))
                )
                # é›»æ°—æ–™é‡‘ä¸Šæ˜‡ï¼ˆå¹´3%ï¼‰)
                price_inflation = 1 + (0.03 * year))
                )
                # è¨­å‚™åŠ£åŒ–ï¼ˆå¹´0.5%åŠ¹ç‡ä½ä¸‹ï¼‰)
                degradation_factor = 1 - (0.005 * year))
                )
                annual_savings = current_annual_savings * learning_factor * price_inflation * degradation_factor)
                future_savings.append(annual_savings))
            )
            # ROIè¨ˆç®—)
            total_savings = sum(future_savings))
            roi_percentage = ((total_savings - investment_amount) / investment_amount) * 100)
            payback_period = investment_amount / current_annual_savings)
            )
            return {)
                "investment_amount": investment_amount,)
                "analysis_period": years,)
                "annual_savings_year1": round(future_savings[0], 0),)
                "total_savings": round(total_savings, 0),)
                "net_profit": round(total_savings - investment_amount, 0),)
                "roi_percentage": round(roi_percentage, 1),)
                "payback_period": round(payback_period, 1),)
                "roi_summary": f"{years}å¹´é–“ROI: {roi_percentage:.1f}% (æŠ•è³‡å›åæœŸé–“: {payback_period:.1f}å¹´)")
            })
            )
        except Exception as e:)
            self.logger.error(f"ROIäºˆæ¸¬ã‚¨ãƒ©ãƒ¼: {e}"))
            return {"error": f"ROIäºˆæ¸¬ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}"})
)
def main():)
    """ãƒ¡ã‚¤ãƒ³å‡¦ç†""")
    ai_engine = SupremeAIPrediction())
    )
    print("ğŸ§  ä¸–ç•Œæœ€é«˜ãƒ¬ãƒ™ãƒ«AIäºˆæ¸¬ã‚¨ãƒ³ã‚¸ãƒ³èµ·å‹•ï¼"))
    print("=========================================="))
    )
    # ãƒ¢ãƒ‡ãƒ«è¨“ç·´)
    print("ğŸ“š æ©Ÿæ¢°å­¦ç¿’ãƒ¢ãƒ‡ãƒ«è¨“ç·´ä¸­..."))
    ai_engine.train_models())
    )
    # æ˜æ—¥ã®äºˆæ¸¬ä¾‹)
    tomorrow = (datetime.now() + timedelta(days=1)).strftime('%Y-%m-%d'))
    prediction = ai_engine.predict_daily_usage(tomorrow, "æ›‡ã‚Š", 25.0, 15.0, 8.0))
    )
    if "error" not in prediction:)
        print(f"\nğŸ”® æ˜æ—¥ã®äºˆæ¸¬: {prediction['prediction_summary']}"))
        print(f"   ä¿¡é ¼åŒºé–“: {prediction['confidence_low']}-{prediction['confidence_high']}kWh"))
    )
    # ä»Šæœˆã®ãƒãƒˆãƒ«äºˆæ¸¬)
    now = datetime.now())
    battle_pred = ai_engine.predict_monthly_battle(now.year, now.month))
    )
    if "error" not in battle_pred:)
        print(f"\nğŸ“Š ä»Šæœˆã®ãƒãƒˆãƒ«äºˆæ¸¬: {battle_pred['battle_summary']}"))
    )
    # ROIäºˆæ¸¬)
    roi = ai_engine.predict_roi(1000000, 10)  # 100ä¸‡å††æŠ•è³‡ã®10å¹´ROI)
    if "error" not in roi:)
        print(f"\nğŸ’° æŠ•è³‡å›åäºˆæ¸¬: {roi['roi_summary']}"))
    )
    print("\nâœ… ä¸–ç•Œæœ€é«˜ãƒ¬ãƒ™ãƒ«AIäºˆæ¸¬ã‚¨ãƒ³ã‚¸ãƒ³æº–å‚™å®Œäº†ï¼"))
)
if __name__ == "__main__":)
    main())
