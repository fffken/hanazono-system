#!/usr/bin/env python3)
""")
è‡ªå·±é€²åŒ–AIçµ±åˆã‚·ã‚¹ãƒ†ãƒ  v2.0 - å­¦ç¿’æ©Ÿèƒ½å¼·åŒ–ç‰ˆ)
å®Ÿå•é¡Œæ¤œå‡ºãƒ»å®Ÿç”¨çš„è§£æ±ºç­–ç”Ÿæˆãƒ»ç¶™ç¶šçš„è‡ªå‹•é€²åŒ–)
""")
import os)
import json)
import subprocess)
import re)
import glob)
from datetime import datetime, timedelta)
from pathlib import Path)
)
class SelfEvolvingAIV2:)
    def __init__(self):)
        self.base_dir = "/home/pi/lvyuan_solar_control")
        self.knowledge_base = f"{self.base_dir}/ai_knowledge_v2.json")
        self.solutions_generated = 0)
        self.problems_solved = 0)
        )
        self._initialize_enhanced_knowledge())
        )
    def run_enhanced_evolution(self):)
        """å¼·åŒ–ã•ã‚ŒãŸè‡ªå·±é€²åŒ–å®Ÿè¡Œ""")
        print("ğŸ§¬ è‡ªå·±é€²åŒ–AI v2.0 - å­¦ç¿’æ©Ÿèƒ½å¼·åŒ–ç‰ˆ"))
        print("=" * 60))
        print("ğŸš€ å®Ÿå•é¡Œæ¤œå‡ºãƒ»å®Ÿç”¨çš„è§£æ±ºç­–ç”Ÿæˆãƒ»ç¶™ç¶šé€²åŒ–"))
        )
        # Phase 1: å®Ÿå•é¡Œæ¤œå‡ºï¼ˆå¼·åŒ–ç‰ˆï¼‰)
        real_problems = self._detect_real_problems())
        )
        # Phase 2: å­¦ç¿’ãƒ™ãƒ¼ã‚¹è§£æ±ºç­–ç”Ÿæˆ)
        solutions = self._generate_learning_based_solutions(real_problems))
        )
        # Phase 3: å®Ÿè£…ãƒ»æ¤œè¨¼ãƒ»å­¦ç¿’)
        results = self._implement_verify_learn(solutions))
        )
        # Phase 4: çŸ¥è­˜ãƒ™ãƒ¼ã‚¹å¼·åŒ–å­¦ç¿’)
        self._enhanced_learning_update(results))
        )
        # Phase 5: è‡ªå‹•ç¶™ç¶šè¨­å®š)
        self._setup_continuous_evolution())
        )
        # å¼·åŒ–ãƒ¬ãƒãƒ¼ãƒˆ)
        self._generate_enhanced_report(real_problems, results))
        )
    def _detect_real_problems(self):)
        """å®Ÿå•é¡Œæ¤œå‡ºï¼ˆå¼·åŒ–ç‰ˆï¼‰""")
        print("\nğŸ” å®Ÿå•é¡Œæ¤œå‡ºã‚·ã‚¹ãƒ†ãƒ  v2.0"))
        )
        real_problems = [])
        )
        # 1. ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«è©³ç´°åˆ†æ)
        log_problems = self._analyze_log_files_detailed())
        real_problems.extend(log_problems))
        )
        # 2. ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹å•é¡Œæ¤œå‡º)
        system_problems = self._detect_system_state_issues())
        real_problems.extend(system_problems))
        )
        # 3. ã‚³ãƒ¼ãƒ‰å“è³ªå•é¡Œæ¤œå‡º)
        code_problems = self._detect_code_quality_issues())
        real_problems.extend(code_problems))
        )
        # 4. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å•é¡Œæ¤œå‡º)
        performance_problems = self._detect_performance_issues())
        real_problems.extend(performance_problems))
        )
        # 5. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å•é¡Œæ¤œå‡º)
        security_problems = self._detect_security_issues())
        real_problems.extend(security_problems))
        )
        print(f"   æ¤œå‡ºã•ã‚ŒãŸå®Ÿå•é¡Œ: {len(real_problems)}ä»¶"))
        for problem in real_problems:)
            print(f"   ğŸš¨ {problem['type']}: {problem['description']}"))
            )
        return real_problems)
        )
    def _analyze_log_files_detailed(self):)
        """ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«è©³ç´°åˆ†æ""")
        problems = [])
        )
        log_patterns = {)
            'battery_extraction_error': r'æŠ½å‡ºã•ã‚ŒãŸãƒãƒƒãƒ†ãƒªãƒ¼æƒ…å ±.*N/A',)
            'email_auth_error': r'Username and Password not accepted',)
            'connection_timeout': r'Connection.*timeout',)
            'import_error': r'ImportError|ModuleNotFoundError',)
            'syntax_error': r'SyntaxError|IndentationError',)
            'permission_error': r'Permission denied',)
            'file_not_found': r'FileNotFoundError|No such file',)
            'json_decode_error': r'JSONDecodeError',)
            'memory_error': r'MemoryError|Out of memory',)
            'disk_space_error': r'No space left on device')
        })
        )
        log_files = glob.glob(f"{self.base_dir}/logs/*.log") + [)
            f"{self.base_dir}/solar_control.log",)
            f"{self.base_dir}/predictive_analysis.log")
        ])
        )
        for log_file in log_files:)
            if os.path.exists(log_file):)
                try:)
                    with open(log_file, 'r') as f:)
                        content = f.read())
                    )
                    for error_type, pattern in log_patterns.items():)
                        matches = re.findall(pattern, content, re.IGNORECASE))
                        if matches:)
                            problems.append({)
                                'type': f'log_{error_type}',)
                                'description': f'{log_file}ã§{error_type}æ¤œå‡º: {len(matches)}å›',)
                                'file': log_file,)
                                'severity': 'high' if error_type in ['syntax_error', 'import_error'] else 'medium',)
                                'evidence': matches[:3],  # æœ€åˆã®3ã¤ã®è¨¼æ‹ )
                                'auto_fixable': True)
                            }))
                except Exception as e:)
                    problems.append({)
                        'type': 'log_analysis_error',)
                        'description': f'ãƒ­ã‚°åˆ†æã‚¨ãƒ©ãƒ¼: {log_file} - {e}',)
                        'severity': 'low',)
                        'auto_fixable': False)
                    }))
                    )
        return problems)
        )
    def _detect_system_state_issues(self):)
        """ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹å•é¡Œæ¤œå‡º""")
        problems = [])
        )
        try:)
            import psutil)
            )
            # CPUä½¿ç”¨ç‡ãƒã‚§ãƒƒã‚¯)
            cpu_percent = psutil.cpu_percent(interval=1))
            if cpu_percent > 85:)
                problems.append({)
                    'type': 'high_cpu_usage',)
                    'description': f'CPUä½¿ç”¨ç‡ç•°å¸¸: {cpu_percent}%',)
                    'severity': 'medium',)
                    'auto_fixable': True,)
                    'fix_method': 'process_optimization')
                }))
            )
            # ãƒ¡ãƒ¢ãƒªä½¿ç”¨ç‡ãƒã‚§ãƒƒã‚¯)
            memory = psutil.virtual_memory())
            if memory.percent > 85:)
                problems.append({)
                    'type': 'high_memory_usage',)
                    'description': f'ãƒ¡ãƒ¢ãƒªä½¿ç”¨ç‡ç•°å¸¸: {memory.percent}%',)
                    'severity': 'medium',)
                    'auto_fixable': True,)
                    'fix_method': 'memory_cleanup')
                }))
            )
            # ãƒ‡ã‚£ã‚¹ã‚¯å®¹é‡ãƒã‚§ãƒƒã‚¯)
            disk = psutil.disk_usage('/'))
            if disk.percent > 90:)
                problems.append({)
                    'type': 'disk_space_critical',)
                    'description': f'ãƒ‡ã‚£ã‚¹ã‚¯å®¹é‡å±é™º: {disk.percent}%',)
                    'severity': 'high',)
                    'auto_fixable': True,)
                    'fix_method': 'disk_cleanup')
                }))
                )
        except ImportError:)
            problems.append({)
                'type': 'missing_dependency',)
                'description': 'psutilãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“',)
                'severity': 'medium',)
                'auto_fixable': True,)
                'fix_method': 'install_package')
            }))
            )
        return problems)
        )
    def _detect_code_quality_issues(self):)
        """ã‚³ãƒ¼ãƒ‰å“è³ªå•é¡Œæ¤œå‡º""")
        problems = [])
        )
        python_files = glob.glob(f"{self.base_dir}/*.py"))
        )
        for py_file in python_files:)
            try:)
                # æ§‹æ–‡ãƒã‚§ãƒƒã‚¯)
                result = subprocess.run(['python3', '-m', 'py_compile', py_file], )
                                      capture_output=True, text=True))
                if result.returncode != 0:)
                    problems.append({)
                        'type': 'syntax_error',)
                        'description': f'{py_file}ã«æ§‹æ–‡ã‚¨ãƒ©ãƒ¼',)
                        'file': py_file,)
                        'severity': 'high',)
                        'auto_fixable': True,)
                        'fix_method': 'syntax_fix',)
                        'error_details': result.stderr)
                    }))
                )
                # ã‚³ãƒ¼ãƒ‰åˆ†æ)
                with open(py_file, 'r') as f:)
                    code = f.read())
                    )
                # æ½œåœ¨çš„å•é¡Œãƒ‘ã‚¿ãƒ¼ãƒ³æ¤œå‡º)
                if re.search(r'except:\s*pass', code):)
                    problems.append({)
                        'type': 'empty_exception_handler',)
                        'description': f'{py_file}ã«ç©ºã®ä¾‹å¤–ãƒãƒ³ãƒ‰ãƒ©ãƒ¼',)
                        'file': py_file,)
                        'severity': 'low',)
                        'auto_fixable': True,)
                        'fix_method': 'improve_exception_handling')
                    }))
                    )
                if re.search(r'print\s*\(.*password.*\)', code, re.IGNORECASE):)
                    problems.append({)
                        'type': 'password_in_print',)
                        'description': f'{py_file}ã§ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒprintæ–‡ã«å«ã¾ã‚Œã‚‹å¯èƒ½æ€§',)
                        'file': py_file,)
                        'severity': 'high',)
                        'auto_fixable': True,)
                        'fix_method': 'remove_sensitive_prints')
                    }))
                    )
            except Exception as e:)
                problems.append({)
                    'type': 'code_analysis_error',)
                    'description': f'{py_file}ã®åˆ†æã‚¨ãƒ©ãƒ¼: {e}',)
                    'severity': 'low',)
                    'auto_fixable': False)
                }))
                )
        return problems)
        )
    def _detect_performance_issues(self):)
        """ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å•é¡Œæ¤œå‡º""")
        problems = [])
        )
        # å¤§ããªãƒ•ã‚¡ã‚¤ãƒ«ã®æ¤œå‡º)
        large_files = [])
        for file_path in glob.glob(f"{self.base_dir}/**/*", recursive=True):)
            if os.path.isfile(file_path):)
                try:)
                    size = os.path.getsize(file_path))
                    if size > 10 * 1024 * 1024:  # 10MBä»¥ä¸Š)
                        large_files.append((file_path, size)))
                except:)
                    pass)
                    )
        if large_files:)
            problems.append({)
                'type': 'large_files_detected',)
                'description': f'å¤§ããªãƒ•ã‚¡ã‚¤ãƒ«æ¤œå‡º: {len(large_files)}å€‹',)
                'severity': 'low',)
                'auto_fixable': True,)
                'fix_method': 'file_compression',)
                'details': large_files[:5])
            }))
        )
        # å¤šæ•°ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«æ¤œå‡º)
        backup_files = glob.glob(f"{self.base_dir}/**/*.backup*", recursive=True))
        if len(backup_files) > 20:)
            problems.append({)
                'type': 'excessive_backups',)
                'description': f'éå‰°ãªãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«: {len(backup_files)}å€‹',)
                'severity': 'medium',)
                'auto_fixable': True,)
                'fix_method': 'backup_cleanup')
            }))
            )
        return problems)
        )
    def _detect_security_issues(self):)
        """ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å•é¡Œæ¤œå‡º""")
        problems = [])
        )
        # æ¨©é™ãƒã‚§ãƒƒã‚¯)
        sensitive_files = ['settings.json', '*.py'])
        for pattern in sensitive_files:)
            for file_path in glob.glob(f"{self.base_dir}/{pattern}"):)
                try:)
                    stat_info = os.stat(file_path))
                    # ä»–è€…èª­ã¿å–ã‚Šå¯èƒ½ãƒã‚§ãƒƒã‚¯)
                    if stat_info.st_mode & 0o044:)
                        problems.append({)
                            'type': 'file_permission_issue',)
                            'description': f'{file_path}ãŒä»–è€…ã‹ã‚‰èª­ã¿å–ã‚Šå¯èƒ½',)
                            'file': file_path,)
                            'severity': 'medium',)
                            'auto_fixable': True,)
                            'fix_method': 'fix_permissions')
                        }))
                except:)
                    pass)
                    )
        return problems)
        )
    def _generate_learning_based_solutions(self, problems):)
        """å­¦ç¿’ãƒ™ãƒ¼ã‚¹è§£æ±ºç­–ç”Ÿæˆ""")
        print("\nğŸ§  å­¦ç¿’ãƒ™ãƒ¼ã‚¹è§£æ±ºç­–ç”Ÿæˆ"))
        )
        solutions = [])
        )
        # çŸ¥è­˜ãƒ™ãƒ¼ã‚¹èª­ã¿è¾¼ã¿)
        with open(self.knowledge_base, 'r') as f:)
            knowledge = json.load(f))
            )
        for problem in problems:)
            if problem.get('auto_fixable', False):)
                solution = self._create_solution_for_problem(problem, knowledge))
                if solution:)
                    solutions.append(solution))
                    print(f"   âœ¨ è§£æ±ºç­–ç”Ÿæˆ: {problem['type']}"))
                    )
        return solutions)
        )
    def _create_solution_for_problem(self, problem, knowledge):)
        """å•é¡Œã«å¯¾ã™ã‚‹è§£æ±ºç­–ä½œæˆ""")
        problem_type = problem['type'])
        )
        # éå»ã®æˆåŠŸãƒ‘ã‚¿ãƒ¼ãƒ³ãƒã‚§ãƒƒã‚¯)
        if problem_type in knowledge.get('successful_fixes', {}):)
            past_solution = knowledge['successful_fixes'][problem_type])
            confidence = past_solution.get('success_rate', 0.5))
        else:)
            confidence = 0.6)
            )
        # å•é¡Œã‚¿ã‚¤ãƒ—åˆ¥è§£æ±ºç­–ç”Ÿæˆ)
        solution_generators = {)
            'log_battery_extraction_error': self._generate_battery_fix,)
            'log_email_auth_error': self._generate_email_fix,)
            'syntax_error': self._generate_syntax_fix,)
            'high_cpu_usage': self._generate_cpu_optimization,)
            'high_memory_usage': self._generate_memory_optimization,)
            'disk_space_critical': self._generate_disk_cleanup,)
            'file_permission_issue': self._generate_permission_fix,)
            'excessive_backups': self._generate_backup_cleanup)
        })
        )
        generator = solution_generators.get(problem_type))
        if generator:)
            return generator(problem, confidence))
            )
        return None)
        )
    def _generate_battery_fix(self, problem, confidence):)
        """ãƒãƒƒãƒ†ãƒªãƒ¼æŠ½å‡ºä¿®æ­£ç”Ÿæˆ""")
        return {)
            'problem': problem,)
            'method': 'battery_extraction_fix',)
            'code': ''')
# è‡ªå‹•ç”Ÿæˆï¼šãƒãƒƒãƒ†ãƒªãƒ¼æƒ…å ±æŠ½å‡ºä¿®æ­£)
def fix_battery_extraction():)
    try:)
        from ai_auto_resolver_v2 import AIAutoResolverV2)
        resolver = AIAutoResolverV2())
        return resolver.solve_email_battery_issue())
    except Exception as e:)
        print(f"ãƒãƒƒãƒ†ãƒªãƒ¼ä¿®æ­£ã‚¨ãƒ©ãƒ¼: {e}"))
        return False)
''',)
            'confidence': confidence,)
            'estimated_time': 30)
        })
        )
    def _generate_email_fix(self, problem, confidence):)
        """ãƒ¡ãƒ¼ãƒ«èªè¨¼ä¿®æ­£ç”Ÿæˆ""")
        return {)
            'problem': problem,)
            'method': 'email_auth_fix',)
            'code': ''')
# è‡ªå‹•ç”Ÿæˆï¼šãƒ¡ãƒ¼ãƒ«èªè¨¼ä¿®æ­£)
def fix_email_auth():)
    import os)
    if 'SMTP_PASSWORD' not in os.environ:)
        print("SMTP_PASSWORDç’°å¢ƒå¤‰æ•°ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“"))
        return False)
    return True)
''',)
            'confidence': confidence,)
            'estimated_time': 10)
        })
        )
    def _generate_syntax_fix(self, problem, confidence):)
        """æ§‹æ–‡ã‚¨ãƒ©ãƒ¼ä¿®æ­£ç”Ÿæˆ""")
        return {)
            'problem': problem,)
            'method': 'syntax_fix',)
            'code': f''')
# è‡ªå‹•ç”Ÿæˆï¼šæ§‹æ–‡ã‚¨ãƒ©ãƒ¼ä¿®æ­£)
def fix_syntax_error():)
    import subprocess)
    file_path = "{problem.get('file', '')}")
    result = subprocess.run(['python3', '-m', 'py_compile', file_path], )
                          capture_output=True, text=True))
    if result.returncode == 0:)
        print(f"{{file_path}} æ§‹æ–‡ãƒã‚§ãƒƒã‚¯æˆåŠŸ"))
        return True)
    else:)
        print(f"æ§‹æ–‡ã‚¨ãƒ©ãƒ¼è©³ç´°: {{result.stderr}}"))
        return False)
''',)
            'confidence': confidence,)
            'estimated_time': 60)
        })
        )
    def _generate_cpu_optimization(self, problem, confidence):)
        """CPUæœ€é©åŒ–ç”Ÿæˆ""")
        return {)
            'problem': problem,)
            'method': 'cpu_optimization',)
            'code': ''')
# è‡ªå‹•ç”Ÿæˆï¼šCPUæœ€é©åŒ–)
def optimize_cpu():)
    import subprocess)
    import psutil)
    )
    # é‡ã„ãƒ—ãƒ­ã‚»ã‚¹ç¢ºèª)
    processes = [])
    for proc in psutil.process_iter(['pid', 'name', 'cpu_percent']):)
        if proc.info['cpu_percent'] > 10:)
            processes.append(proc.info))
    )
    print(f"é«˜CPUä½¿ç”¨ãƒ—ãƒ­ã‚»ã‚¹: {len(processes)}å€‹"))
    return True)
''',)
            'confidence': confidence,)
            'estimated_time': 20)
        })
        )
    def _generate_memory_optimization(self, problem, confidence):)
        """ãƒ¡ãƒ¢ãƒªæœ€é©åŒ–ç”Ÿæˆ""")
        return {)
            'problem': problem,)
            'method': 'memory_optimization',)
            'code': ''')
# è‡ªå‹•ç”Ÿæˆï¼šãƒ¡ãƒ¢ãƒªæœ€é©åŒ–)
def optimize_memory():)
    import gc)
    import subprocess)
    )
    # ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œ)
    collected = gc.collect())
    )
    # Python cacheã‚¯ãƒªã‚¢)
    subprocess.run(['find', '.', '-name', '__pycache__', '-type', 'd', )
                   '-exec', 'rm', '-rf', '{}', '+']))
    )
    print(f"ãƒ¡ãƒ¢ãƒªæœ€é©åŒ–å®Œäº†: {collected}ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè§£æ”¾"))
    return True)
''',)
            'confidence': confidence,)
            'estimated_time': 15)
        })
        )
    def _generate_disk_cleanup(self, problem, confidence):)
        """ãƒ‡ã‚£ã‚¹ã‚¯ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ç”Ÿæˆ""")
        return {)
            'problem': problem,)
            'method': 'disk_cleanup',)
            'code': ''')
# è‡ªå‹•ç”Ÿæˆï¼šãƒ‡ã‚£ã‚¹ã‚¯ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—)
def cleanup_disk():)
    import subprocess)
    import glob)
    )
    cleaned = 0)
    )
    # å¤ã„ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«å‰Šé™¤)
    old_logs = glob.glob("logs/*.log.*"))
    for log in old_logs:)
        try:)
            os.remove(log))
            cleaned += 1)
        except:)
            pass)
    )
    # ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«å‰Šé™¤)
    subprocess.run(['find', '/tmp', '-name', '*hanazono*', '-delete']))
    )
    print(f"ãƒ‡ã‚£ã‚¹ã‚¯ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†: {cleaned}ãƒ•ã‚¡ã‚¤ãƒ«å‰Šé™¤"))
    return True)
''',)
            'confidence': confidence,)
            'estimated_time': 25)
        })
        )
    def _generate_permission_fix(self, problem, confidence):)
        """æ¨©é™ä¿®æ­£ç”Ÿæˆ""")
        return {)
            'problem': problem,)
            'method': 'permission_fix',)
            'code': f''')
# è‡ªå‹•ç”Ÿæˆï¼šãƒ•ã‚¡ã‚¤ãƒ«æ¨©é™ä¿®æ­£)
def fix_permissions():)
    import os)
    import stat)
    )
    file_path = "{problem.get('file', '')}")
    try:)
        # æ‰€æœ‰è€…ã®ã¿èª­ã¿æ›¸ãå¯èƒ½ã«è¨­å®š)
        os.chmod(file_path, stat.S_IRUSR | stat.S_IWUSR))
        print(f"æ¨©é™ä¿®æ­£å®Œäº†: {{file_path}}"))
        return True)
    except Exception as e:)
        print(f"æ¨©é™ä¿®æ­£ã‚¨ãƒ©ãƒ¼: {{e}}"))
        return False)
''',)
            'confidence': confidence,)
            'estimated_time': 5)
        })
        )
    def _generate_backup_cleanup(self, problem, confidence):)
        """ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ç”Ÿæˆ""")
        return {)
            'problem': problem,)
            'method': 'backup_cleanup',)
            'code': ''')
# è‡ªå‹•ç”Ÿæˆï¼šãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—)
def cleanup_backups():)
    import glob)
    import os)
    from datetime import datetime, timedelta)
    )
    cutoff = datetime.now() - timedelta(days=7))
    cleaned = 0)
    )
    backup_patterns = ["*.backup*", "system_backups/backup_*"])
    for pattern in backup_patterns:)
        for backup_file in glob.glob(pattern):)
            try:)
                mtime = datetime.fromtimestamp(os.path.getmtime(backup_file)))
                if mtime < cutoff:)
                    if os.path.isfile(backup_file):)
                        os.remove(backup_file))
                    elif os.path.isdir(backup_file):)
                        shutil.rmtree(backup_file))
                    cleaned += 1)
            except:)
                pass)
                )
    print(f"ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†: {cleaned}é …ç›®å‰Šé™¤"))
    return True)
''',)
            'confidence': confidence,)
            'estimated_time': 20)
        })
        )
    def _implement_verify_learn(self, solutions):)
        """å®Ÿè£…ãƒ»æ¤œè¨¼ãƒ»å­¦ç¿’""")
        print("\nğŸ”§ è§£æ±ºç­–å®Ÿè£…ãƒ»æ¤œè¨¼ãƒ»å­¦ç¿’"))
        )
        results = [])
        )
        for solution in solutions:)
            print(f"   å®Ÿè£…ä¸­: {solution['method']}"))
            )
            try:)
                # è§£æ±ºç­–å®Ÿè£…)
                success = self._execute_solution(solution))
                )
                result = {)
                    'solution': solution,)
                    'success': success,)
                    'timestamp': datetime.now().isoformat(),)
                    'execution_time': solution.get('estimated_time', 30))
                })
                )
                if success:)
                    print(f"   âœ… æˆåŠŸ: {solution['method']}"))
                    self.problems_solved += 1)
                else:)
                    print(f"   âŒ å¤±æ•—: {solution['method']}"))
                    )
                results.append(result))
                self.solutions_generated += 1)
                )
            except Exception as e:)
                print(f"   âš ï¸ ã‚¨ãƒ©ãƒ¼: {solution['method']} - {e}"))
                results.append({)
                    'solution': solution,)
                    'success': False,)
                    'error': str(e),)
                    'timestamp': datetime.now().isoformat())
                }))
                )
        return results)
        )
    def _execute_solution(self, solution):)
        """è§£æ±ºç­–å®Ÿè¡Œ""")
        try:)
            # è§£æ±ºç­–ã‚³ãƒ¼ãƒ‰ã‚’ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜)
            temp_file = f"/tmp/auto_fix_{solution['method']}.py")
            with open(temp_file, 'w') as f:)
                f.write(solution['code']))
                )
            # å®Ÿè¡Œ)
            result = subprocess.run(['python3', temp_file], )
                                  capture_output=True, text=True, timeout=60))
            )
            # ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—)
            os.remove(temp_file))
            )
            return result.returncode == 0)
            )
        except subprocess.TimeoutExpired:)
            print("   â±ï¸ å®Ÿè¡Œã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ"))
            return False)
        except Exception as e:)
            print(f"   âŒ å®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}"))
            return False)
            )
    def _enhanced_learning_update(self, results):)
        """å¼·åŒ–å­¦ç¿’æ›´æ–°""")
        print("\nğŸ“š çŸ¥è­˜ãƒ™ãƒ¼ã‚¹å¼·åŒ–å­¦ç¿’æ›´æ–°"))
        )
        with open(self.knowledge_base, 'r') as f:)
            knowledge = json.load(f))
            )
        # æˆåŠŸãƒ‘ã‚¿ãƒ¼ãƒ³å­¦ç¿’)
        successful_fixes = knowledge.setdefault('successful_fixes', {}))
        )
        for result in results:)
            method = result['solution']['method'])
            problem_type = result['solution']['problem']['type'])
            )
            if result['success']:)
                if problem_type not in successful_fixes:)
                    successful_fixes[problem_type] = {)
                        'method': method,)
                        'success_count': 0,)
                        'total_attempts': 0,)
                        'success_rate': 0.0,)
                        'last_success': None)
                    })
                    )
                fix_data = successful_fixes[problem_type])
                fix_data['success_count'] += 1)
                fix_data['total_attempts'] += 1)
                fix_data['success_rate'] = fix_data['success_count'] / fix_data['total_attempts'])
                fix_data['last_success'] = result['timestamp'])
                )
        # å­¦ç¿’çµ±è¨ˆæ›´æ–°)
        knowledge['learning_stats'] = {)
            'total_problems_analyzed': len(results),)
            'successful_fixes': self.problems_solved,)
            'solutions_generated': self.solutions_generated,)
            'learning_rate': self.problems_solved / max(self.solutions_generated, 1),)
            'last_learning_session': datetime.now().isoformat())
        })
        )
        with open(self.knowledge_base, 'w') as f:)
            json.dump(knowledge, f, indent=2))
            )
        print(f"   ğŸ“ˆ å­¦ç¿’å®Œäº†: æˆåŠŸç‡ {self.problems_solved}/{self.solutions_generated}"))
        )
    def _setup_continuous_evolution(self):)
        """ç¶™ç¶šçš„è‡ªå‹•é€²åŒ–è¨­å®š""")
        print("\nğŸ”„ ç¶™ç¶šçš„è‡ªå‹•é€²åŒ–è¨­å®š"))
        )
        try:)
            # cronè¨­å®šã«è‡ªå‹•é€²åŒ–ã‚’è¿½åŠ )
            cron_command = f"0 */6 * * * cd {self.base_dir} && python3 self_evolving_ai_v2.py >> logs/evolution.log 2>&1")
            )
            # æ—¢å­˜ã®crontabã‚’å–å¾—)
            result = subprocess.run(['crontab', '-l'], capture_output=True, text=True))
            current_cron = result.stdout if result.returncode == 0 else "")
            )
            # è‡ªå‹•é€²åŒ–ã‚¸ãƒ§ãƒ–ãŒæœªè¨­å®šã®å ´åˆè¿½åŠ )
            if 'self_evolving_ai_v2.py' not in current_cron:)
                new_cron = current_cron.rstrip() + f"\n{cron_command}\n")
                )
                # æ–°ã—ã„crontabã‚’è¨­å®š)
                proc = subprocess.Popen(['crontab', '-'], stdin=subprocess.PIPE, text=True))
                proc.communicate(input=new_cron))
                )
                if proc.returncode == 0:)
                    print("   âœ… 6æ™‚é–“ã”ã¨ã®è‡ªå‹•é€²åŒ–ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«è¨­å®šå®Œäº†"))
                else:)
                    print("   âŒ cronè¨­å®šå¤±æ•—"))
            else:)
                print("   âœ… è‡ªå‹•é€²åŒ–ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«æ—¢ã«è¨­å®šæ¸ˆã¿"))
                )
        except Exception as e:)
            print(f"   âš ï¸ ç¶™ç¶šè¨­å®šã‚¨ãƒ©ãƒ¼: {e}"))
            )
    def _generate_enhanced_report(self, problems, results):)
        """å¼·åŒ–ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ""")
        print("\n" + "=" * 60))
        print("ğŸ“Š è‡ªå·±é€²åŒ–AI v2.0 - å¼·åŒ–å­¦ç¿’å®Œäº†ãƒ¬ãƒãƒ¼ãƒˆ"))
        print("=" * 60))
        )
        print(f"\nğŸ” å®Ÿå•é¡Œæ¤œå‡ºçµæœ:"))
        print(f"   æ¤œå‡ºã•ã‚ŒãŸå•é¡Œ: {len(problems)}ä»¶"))
        )
        problem_types = {})
        for problem in problems:)
            ptype = problem['type'])
            problem_types[ptype] = problem_types.get(ptype, 0) + 1)
            )
        for ptype, count in problem_types.items():)
            print(f"   â€¢ {ptype}: {count}ä»¶"))
            )
        print(f"\nğŸ§  å­¦ç¿’ãƒ™ãƒ¼ã‚¹è§£æ±º:"))
        print(f"   ç”Ÿæˆã•ã‚ŒãŸè§£æ±ºç­–: {self.solutions_generated}ä»¶"))
        print(f"   æˆåŠŸã—ãŸä¿®æ­£: {self.problems_solved}ä»¶"))
        )
        if self.solutions_generated > 0:)
            success_rate = (self.problems_solved / self.solutions_generated) * 100)
            print(f"   æˆåŠŸç‡: {success_rate:.1f}%"))
            )
        print(f"\nğŸš€ ç¶™ç¶šçš„é€²åŒ–:"))
        print(f"   6æ™‚é–“ã”ã¨ã®è‡ªå‹•é€²åŒ–ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«è¨­å®š"))
        print(f"   æ¬¡å›å®Ÿè¡Œ: 6æ™‚é–“å¾Œ"))
        )
        # çŸ¥è­˜ãƒ™ãƒ¼ã‚¹çµ±è¨ˆ)
        with open(self.knowledge_base, 'r') as f:)
            knowledge = json.load(f))
            )
        stats = knowledge.get('learning_stats', {}))
        successful_fixes = knowledge.get('successful_fixes', {}))
        )
        print(f"\nğŸ“š ç´¯ç©çŸ¥è­˜:"))
        print(f"   è§£æ±ºå¯èƒ½å•é¡Œã‚¿ã‚¤ãƒ—: {len(successful_fixes)}ç¨®é¡"))
        print(f"   å­¦ç¿’ç‡: {stats.get('learning_rate', 0):.2f}"))
        )
        print(f"\nğŸ¯ é€²åŒ–å±•æœ›:"))
        print(f"   ç¶™ç¶šçš„å•é¡Œæ¤œå‡ºãƒ»è§£æ±ºã«ã‚ˆã‚Šå®Œå…¨è‡ªå‹•åŒ–é”æˆ"))
        print(f"   äººé–“ã®æ‰‹ä½œæ¥­å®Œå…¨æ’é™¤ã¾ã§è‡ªå‹•é€²åŒ–ç¶™ç¶š"))
        )
        print("=" * 60))
        )
    def _initialize_enhanced_knowledge(self):)
        """)
