import os
import sqlite3
import logging
from datetime import datetime

# 必要なパターンクラス/ストレージクラスのダミー実装（既存でimport可能なら差し替え可）
class MemoryOptimizedStorage:
    def __init__(self, max_memory_mb=50):
        self.max_memory_mb = max_memory_mb

class WeightedPattern:
    def __init__(self, decay_rate=0.98):
        self.decay_rate = decay_rate
    def update(self, value): pass

class AdaptivePattern:
    def __init__(self, adaptation_rate=0.08):
        self.adaptation_rate = adaptation_rate
    def update(self, value): pass

class LearningPattern:
    def __init__(self, learning_rate=0.03):
        self.learning_rate = learning_rate
    def update(self, value): pass

class TrustPattern:
    def __init__(self):
        pass
    def update(self, value): pass

class DataCompressor:
    def compress(self, patterns): pass

# 必須：ダミーInteractionDataクラス（importエラー防止用）
class InteractionData:
    def __init__(self, **kwargs):
        self.data = kwargs

class FFPreferenceLearner:
    """FF管理者好み学習システム（DD2改善完全版）"""

    def __init__(self, storage_path: str = None):
        self.storage = MemoryOptimizedStorage(max_memory_mb=50)
        self.preference_patterns = {
            'code_style': WeightedPattern(decay_rate=0.98),
            'complexity_level': AdaptivePattern(adaptation_rate=0.08),
            'error_tolerance': LearningPattern(learning_rate=0.03),
            'automation_acceptance': TrustPattern()
        }
        self.storage_path = storage_path or os.path.expanduser('~/.hcqas/ff_preferences.db')
        os.makedirs(os.path.dirname(self.storage_path), exist_ok=True)
        self._init_database()
        self.learning_active = True
        self.interaction_count = 0
        self.last_analysis_time = datetime.now()
        self.data_compressor = DataCompressor()
        logging.info("FF Preference Learner initialized with DD2 optimizations")

    def _init_database(self):
        with sqlite3.connect(self.storage_path) as conn:
            conn.execute('''
                CREATE TABLE IF NOT EXISTS interactions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    timestamp TEXT NOT NULL,
                    ff_request TEXT NOT NULL,
                    choices_made TEXT NOT NULL
                )
            ''')

    # 必須API: シグニチャ一致＋必ず何かしら返す（呼び出しエラー防止）
    def learn_from_interaction(self, interaction_data, *args, **kwargs):
        """
        インタラクションデータから好みを学習。
        呼び出し側から余計な引数が来ても無視できるよう*args, **kwargs付き
        """
        if not self.learning_active:
            return
        try:
            for pattern_name, pattern in self.preference_patterns.items():
                if hasattr(interaction_data, pattern_name):
                    pattern.update(getattr(interaction_data, pattern_name))
                elif isinstance(interaction_data, dict) and pattern_name in interaction_data:
                    pattern.update(interaction_data[pattern_name])
            self.interaction_count += 1
            self.last_analysis_time = datetime.now()
            self.data_compressor.compress(self.preference_patterns)
        except Exception as e:
            logging.warning(f"Learning from interaction failed: {e}")

    def get_ff_preferences(self, *args, **kwargs):
        """
        FF管理者の好みを返すAPI（ダミー：最低限のdictで返却）
        """
        return {
            "code_style": "default",
            "complexity_level": "medium",
            "error_tolerance": 0.1,
            "automation_acceptance": True
        }

    def predict_ff_satisfaction(self, proposal, *args, **kwargs):
        """
        提案内容に対する満足度を予測（ダミー値で0.5を返す）
        """
        return 0.5
