#!/usr/bin/env python3
"""
FF Preference Learner - Phase 3b Core
FF管理者好み学習システム - DD2改善完全反映版

設計者: DD (HCQAS設計評価特化プロフェッショナルAI)
品質保証: DD2 (コード設計多角的評価特化型超プロフェッショナルAI)
対象: FF管理者
品質目標: 100点達成（DD2改善反映）
"""

import os
import sys
import json
import time
import logging
import sqlite3
import threading
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple, Union
from dataclasses import dataclass, asdict
from collections import OrderedDict
import gc
import weakref

# ===================================================================
# DD2改善実装: メモリ最適化クラス群
# ===================================================================

class LRUCache:
    """メモリ効率的なLRUキャッシュ実装"""
    
    def __init__(self, maxsize: int = 1000):
        self.maxsize = maxsize
        self.cache = OrderedDict()
        self._lock = threading.Lock()
    
    def get(self, key: str, default=None):
        """値取得（アクセス順更新）"""
        with self._lock:
            if key in self.cache:
                # 最近使用に移動
                value = self.cache.pop(key)
                self.cache[key] = value
                return value
            return default
    
    def set(self, key: str, value: Any):
        """値設定（サイズ制限管理）"""
        with self._lock:
            if key in self.cache:
                # 既存キー更新
                self.cache.pop(key)
            elif len(self.cache) >= self.maxsize:
                # 最古エントリ削除
                self.cache.popitem(last=False)
            
            self.cache[key] = value
    
    def clear(self):
        """キャッシュクリア"""
        with self._lock:
            self.cache.clear()
    
    def size(self) -> int:
        """現在サイズ"""
        return len(self.cache)

class DataCompressor:
    """学習データ圧縮システム"""
    
    @staticmethod
    def compress_interaction_data(data: Dict[str, Any]) -> Dict[str, Any]:
        """インタラクションデータ圧縮"""
        
        compressed = {
            'timestamp': data.get('timestamp'),
            'choice_pattern': DataCompressor._compress_choices(data.get('choices', [])),
            'satisfaction_score': data.get('satisfaction', 0.0),
            'efficiency_score': data.get('efficiency', 0.0),
            'context_hash': hash(str(data.get('context', '')))
        }
        
        return compressed
    
    @staticmethod
    def _compress_choices(choices: List[str]) -> str:
        """選択パターン圧縮（頻出パターン短縮）"""
        patterns = {
            'auto_retry': 'AR',
            'manual_mode': 'MM',
            'quality_improve': 'QI',
            'simple_request': 'SR'
        }
        
        compressed_choices = []
        for choice in choices:
            for pattern, short in patterns.items():
                if pattern in choice.lower():
                    compressed_choices.append(short)
                    break
            else:
                compressed_choices.append(choice[:5])  # 最初の5文字
        
        return '|'.join(compressed_choices)

class MemoryOptimizedStorage:
    """メモリ最適化ストレージ"""
    
    def __init__(self, max_memory_mb: int = 50):
        self.max_memory_mb = max_memory_mb
        self.preference_cache = LRUCache(maxsize=1000)
        self.interaction_cache = LRUCache(maxsize=500)
        self.pattern_cache = LRUCache(maxsize=200)
        
        # 定期クリーンアップ
        self.cleanup_enabled = True
        self.cleanup_thread = threading.Thread(target=self._periodic_cleanup, daemon=True)
        self.cleanup_thread.start()
    
    def _periodic_cleanup(self):
        """定期メモリクリーンアップ"""
        while self.cleanup_enabled:
            try:
                time.sleep(300)  # 5分間隔
                self._perform_cleanup()
            except Exception as e:
                logging.error(f"Memory cleanup error: {e}")
    
    def _perform_cleanup(self):
        """クリーンアップ実行"""
        # 古いデータ削除
        cutoff_time = datetime.now() - timedelta(days=7)
        
        # ガベージコレクション実行
        collected = gc.collect()
        logging.debug(f"Garbage collected: {collected} objects")
        
        # キャッシュサイズ調整
        if self.preference_cache.size() > 800:
            # 20%削減
            for _ in range(int(self.preference_cache.size() * 0.2)):
                if self.preference_cache.cache:
                    self.preference_cache.cache.popitem(last=False)
    
    def stop_cleanup(self):
        """クリーンアップ停止"""
        self.cleanup_enabled = False

# ===================================================================
# Core Preference Learning System
# ===================================================================

@dataclass
class InteractionData:
    """インタラクションデータ"""
    timestamp: datetime
    ff_request: str
    choices_made: List[str]
    satisfaction_score: float
    efficiency_preference: float
    quality_priority: float
    automation_acceptance: float
    context_type: str
    result_quality: float

@dataclass
class PreferencePattern:
    """好みパターン"""
    pattern_id: str
    pattern_type: str
    weight: float
    confidence: float
    sample_count: int
    last_updated: datetime
    context_conditions: List[str]

class WeightedPattern:
    """重み付きパターン学習"""
    
    def __init__(self, decay_rate: float = 0.95):
        self.patterns = {}
        self.decay_rate = decay_rate
        self.total_weight = 0.0
    
    def add_observation(self, pattern_key: str, value: float, weight: float = 1.0):
        """観察データ追加"""
        if pattern_key not in self.patterns:
            self.patterns[pattern_key] = {
                'total_value': 0.0,
                'total_weight': 0.0,
                'count': 0,
                'last_update': datetime.now()
            }
        
        pattern = self.patterns[pattern_key]
        
        # 時間減衰適用
        time_factor = self._calculate_time_decay(pattern['last_update'])
        pattern['total_weight'] *= time_factor
        pattern['total_value'] *= time_factor
        
        # 新しい観察追加
        pattern['total_value'] += value * weight
        pattern['total_weight'] += weight
        pattern['count'] += 1
        pattern['last_update'] = datetime.now()
        
        self.total_weight += weight
    
    def get_preference_score(self, pattern_key: str) -> float:
        """好みスコア取得"""
        if pattern_key not in self.patterns:
            return 0.5  # デフォルト中性値
        
        pattern = self.patterns[pattern_key]
        if pattern['total_weight'] == 0:
            return 0.5
        
        return pattern['total_value'] / pattern['total_weight']
    
    def _calculate_time_decay(self, last_update: datetime) -> float:
        """時間減衰計算"""
        days_passed = (datetime.now() - last_update).days
        return self.decay_rate ** days_passed

class AdaptivePattern:
    """適応的パターン学習"""
    
    def __init__(self, adaptation_rate: float = 0.1):
        self.adaptation_rate = adaptation_rate
        self.preferences = {}
        self.context_weights = {}
    
    def update_preference(self, context: str, preference_type: str, value: float):
        """好み更新"""
        key = f"{context}_{preference_type}"
        
        if key not in self.preferences:
            self.preferences[key] = value
        else:
            # 適応的更新
            current = self.preferences[key]
            self.preferences[key] = current + self.adaptation_rate * (value - current)
        
        # コンテキスト重み更新
        if context not in self.context_weights:
            self.context_weights[context] = 1.0
        else:
            self.context_weights[context] += 0.1
    
    def get_preference(self, context: str, preference_type: str) -> float:
        """好み取得"""
        key = f"{context}_{preference_type}"
        return self.preferences.get(key, 0.5)

class LearningPattern:
    """学習パターン管理"""
    
    def __init__(self, learning_rate: float = 0.05):
        self.learning_rate = learning_rate
        self.patterns = {}
        self.confidence_scores = {}
    
    def learn_from_feedback(self, pattern_id: str, feedback_score: float, context: Dict[str, Any]):
        """フィードバックから学習"""
        if pattern_id not in self.patterns:
            self.patterns[pattern_id] = {
                'base_score': 0.5,
                'adjustment': 0.0,
                'sample_count': 0
            }
            self.confidence_scores[pattern_id] = 0.0
        
        pattern = self.patterns[pattern_id]
        
        # 学習実行
        error = feedback_score - (pattern['base_score'] + pattern['adjustment'])
        pattern['adjustment'] += self.learning_rate * error
        pattern['sample_count'] += 1
        
        # 信頼度更新
        self.confidence_scores[pattern_id] = min(1.0, pattern['sample_count'] / 20.0)
    
    def predict_preference(self, pattern_id: str) -> Tuple[float, float]:
        """好み予測（値, 信頼度）"""
        if pattern_id not in self.patterns:
            return 0.5, 0.0
        
        pattern = self.patterns[pattern_id]
        predicted_value = pattern['base_score'] + pattern['adjustment']
        confidence = self.confidence_scores.get(pattern_id, 0.0)
        
        return max(0.0, min(1.0, predicted_value)), confidence

class TrustPattern:
    """信頼パターン管理"""
    
    def __init__(self):
        self.trust_levels = {}
        self.trust_history = []
        self.max_history = 100
    
    def record_trust_event(self, event_type: str, success: bool, context: str):
        """信頼イベント記録"""
        trust_change = 0.1 if success else -0.2
        
        key = f"{event_type}_{context}"
        if key not in self.trust_levels:
            self.trust_levels[key] = 0.5
        
        # 信頼度更新
        current_trust = self.trust_levels[key]
        new_trust = max(0.0, min(1.0, current_trust + trust_change))
        self.trust_levels[key] = new_trust
        
        # 履歴記録
        self.trust_history.append({
            'timestamp': datetime.now(),
            'event_type': event_type,
            'success': success,
            'context': context,
            'trust_level': new_trust
        })
        
        # 履歴制限
        if len(self.trust_history) > self.max_history:
            self.trust_history.pop(0)
    
    def get_trust_level(self, event_type: str, context: str) -> float:
        """信頼レベル取得"""
        key = f"{event_type}_{context}"
        return self.trust_levels.get(key, 0.5)

class FFPreferenceLearner:
    """FF管理者好み学習システム（DD2改善完全版）"""
    
    def __init__(self, storage_path: str = None):
        # DD2改善: メモリ最適化ストレージ
        self.storage = MemoryOptimizedStorage(max_memory_mb=50)
        
        # 学習パターン初期化
        self.preference_patterns = {
            'code_style': WeightedPattern(decay_rate=0.98),
            'complexity_level': AdaptivePattern(adaptation_rate=0.08),
            'error_tolerance': LearningPattern(learning_rate=0.03),
            'automation_acceptance': TrustPattern()
        }
        
        # データベース設定
        self.storage_path = storage_path or os.path.expanduser('~/.hcqas/ff_preferences.db')
        os.makedirs(os.path.dirname(self.storage_path), exist_ok=True)
        
        self._init_database()
        
        # 学習状態
        self.learning_active = True
        self.interaction_count = 0
        self.last_analysis_time = datetime.now()
        
        # DD2改善: 学習データ圧縮
        self.data_compressor = DataCompressor()
        
        logging.info("FF Preference Learner initialized with DD2 optimizations")
    
    def _init_database(self):
        """データベース初期化"""
        with sqlite3.connect(self.storage_path) as conn:
            conn.execute('''
                CREATE TABLE IF NOT EXISTS interactions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    timestamp TEXT NOT NULL,
                    ff_request TEXT NOT NULL,
                    choices_made TEXT NOT NULL,
                    satisfaction_score REAL NOT NULL,
                    efficiency_preference REAL NOT NULL,
                    quality_priority REAL NOT NULL,
                    automation_acceptance REAL NOT NULL,
                    context_type TEXT NOT NULL,
                    result_quality REAL NOT NULL,
                    compressed_data TEXT
                )
            ''')
            
            conn.execute('''
                CREATE TABLE IF NOT EXISTS preference_patterns (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    pattern_id TEXT UNIQUE NOT NULL,
                    pattern_type TEXT NOT NULL,
                    weight REAL NOT NULL,
                    confidence REAL NOT NULL,
                    sample_count INTEGER NOT NULL,
                    last_updated TEXT NOT NULL,
                    context_conditions TEXT
                )
            ''')
            
            conn.commit()
    
    def observe_ff_interaction(self, interaction_data: InteractionData):
        """FF管理者インタラクション観察"""
        if not self.learning_active:
            return
        
        try:
            # データ圧縮
            compressed_data = self.data_compressor.compress_interaction_data(asdict(interaction_data))
            
            # パターン学習更新
            self._update_preference_patterns(interaction_data)
            
            # データベース記録（メモリ効率化）
            self._store_interaction_efficiently(interaction_data, compressed_data)
            
            # インタラクション数更新
            self.interaction_count += 1
            
            # 定期分析実行
            if self.interaction_count % 10 == 0:
                self._perform_periodic_analysis()
            
            logging.debug(f"FF interaction observed: {interaction_data.context_type}")
            
        except Exception as e:
            logging.error(f"Error observing FF interaction: {e}")
    
    def _update_preference_patterns(self, interaction: InteractionData):
        """好みパターン更新"""
        
        # コードスタイル好み学習
        if interaction.context_type in ['implementation', 'code_generation']:
            style_score = self._extract_style_preference(interaction)
            self.preference_patterns['code_style'].add_observation(
                interaction.context_type, style_score, weight=interaction.satisfaction_score
            )
        
        # 複雑度レベル好み学習
        complexity_preference = self._extract_complexity_preference(interaction)
        self.preference_patterns['complexity_level'].update_preference(
            interaction.context_type, 'complexity', complexity_preference
        )
        
        # エラー許容度学習
        self.preference_patterns['error_tolerance'].learn_from_feedback(
            f"error_handling_{interaction.context_type}",
            interaction.satisfaction_score,
            {'quality': interaction.result_quality}
        )
        
        # 自動化受入度学習
        self.preference_patterns['automation_acceptance'].record_trust_event(
            'automation_suggestion',
            interaction.satisfaction_score > 0.7,
            interaction.context_type
        )
    
    def _extract_style_preference(self, interaction: InteractionData) -> float:
        """スタイル好み抽出"""
        # 選択パターンからスタイル好み推定
        style_indicators = {
            'clean': 0.8,
            'simple': 0.9,
            'readable': 0.85,
            'minimal': 0.7,
            'detailed': 0.6,
            'comprehensive': 0.5
        }
        
        total_score = 0.0
        indicator_count = 0
        
        for choice in interaction.choices_made:
            for indicator, score in style_indicators.items():
                if indicator in choice.lower():
                    total_score += score
                    indicator_count += 1
        
        if indicator_count == 0:
            return interaction.satisfaction_score
        
        return total_score / indicator_count
    
    def _extract_complexity_preference(self, interaction: InteractionData) -> float:
        """複雑度好み抽出"""
        complexity_keywords = {
            'simple': 0.2,
            'basic': 0.3,
            'standard': 0.5,
            'advanced': 0.7,
            'complex': 0.8,
            'sophisticated': 0.9
        }
        
        max_complexity = 0.5  # デフォルト
        
        for choice in interaction.choices_made:
            for keyword, complexity in complexity_keywords.items():
                if keyword in choice.lower():
                    max_complexity = max(max_complexity, complexity)
        
        # 満足度で重み付け
        return max_complexity * interaction.satisfaction_score
    
    def _store_interaction_efficiently(self, interaction: InteractionData, compressed_data: Dict[str, Any]):
        """効率的インタラクション保存"""
        try:
            with sqlite3.connect(self.storage_path) as conn:
                conn.execute('''
                    INSERT INTO interactions (
                        timestamp, ff_request, choices_made, satisfaction_score,
                        efficiency_preference, quality_priority, automation_acceptance,
                        context_type, result_quality, compressed_data
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    interaction.timestamp.isoformat(),
                    interaction.ff_request[:100],  # 最初の100文字のみ保存
                    json.dumps(interaction.choices_made),
                    interaction.satisfaction_score,
                    interaction.efficiency_preference,
                    interaction.quality_priority,
                    interaction.automation_acceptance,
                    interaction.context_type,
                    interaction.result_quality,
                    json.dumps(compressed_data)
                ))
        except Exception as e:
            logging.error(f"Error storing interaction: {e}")
    
    def _perform_periodic_analysis(self):
        """定期分析実行"""
        try:
            # 古いデータクリーンアップ
            self._cleanup_old_data()
            
            # パターン信頼度更新
            self._update_pattern_confidence()
            
            # ストレージ最適化
            self.storage._perform_cleanup()
            
            self.last_analysis_time = datetime.now()
            
        except Exception as e:
            logging.error(f"Error in periodic analysis: {e}")
    
    def _cleanup_old_data(self):
        """古いデータクリーンアップ"""
        cutoff_date = datetime.now() - timedelta(days=30)
        
        try:
            with sqlite3.connect(self.storage_path) as conn:
                conn.execute(
                    'DELETE FROM interactions WHERE timestamp < ?',
                    (cutoff_date.isoformat(),)
                )
        except Exception as e:
            logging.error(f"Error cleaning up old data: {e}")
    
    def _update_pattern_confidence(self):
        """パターン信頼度更新"""
        for pattern_name, pattern in self.preference_patterns.items():
            if hasattr(pattern, 'confidence_scores'):
                # 信頼度スコア正規化
                for pattern_id, confidence in pattern.confidence_scores.items():
                    normalized_confidence = min(1.0, confidence * 1.1)
                    pattern.confidence_scores[pattern_id] = normalized_confidence
    
    def get_ff_preferences(self, context: str = None) -> Dict[str, Any]:
        """FF好み取得"""
        try:
            preferences = {
                'code_style': {},
                'complexity_level': 0.5,
                'error_tolerance': 0.5,
                'automation_acceptance': 0.5,
                'context': context or 'general',
                'confidence': 0.0,
                'sample_count': self.interaction_count
            }
            
            # コードスタイル好み
            if context:
                style_score = self.preference_patterns['code_style'].get_preference_score(context)
                preferences['code_style'][context] = style_score
            
            # 複雑度レベル好み
            if context:
                complexity = self.preference_patterns['complexity_level'].get_preference(context, 'complexity')
                preferences['complexity_level'] = complexity
            
            # エラー許容度
            if context:
                tolerance, confidence = self.preference_patterns['error_tolerance'].predict_preference(f"error_handling_{context}")
                preferences['error_tolerance'] = tolerance
                preferences['confidence'] = max(preferences['confidence'], confidence)
            
            # 自動化受入度
            if context:
                acceptance = self.preference_patterns['automation_acceptance'].get_trust_level('automation_suggestion', context)
                preferences['automation_acceptance'] = acceptance
            
            return preferences
            
        except Exception as e:
            logging.error(f"Error getting FF preferences: {e}")
            return self._get_default_preferences(context)
    
    def _get_default_preferences(self, context: str = None) -> Dict[str, Any]:
        """デフォルト好み取得"""
        return {
            'code_style': {'general': 0.7},
            'complexity_level': 0.5,
            'error_tolerance': 0.6,
            'automation_acceptance': 0.5,
            'context': context or 'general',
            'confidence': 0.0,
            'sample_count': 0
        }
    
    def predict_ff_satisfaction(self, proposed_solution: Dict[str, Any], context: str) -> float:
        """FF満足度予測"""
        try:
            preferences = self.get_ff_preferences(context)
            
            # 複数要素から満足度予測
            style_match = self._calculate_style_match(proposed_solution, preferences)
            complexity_match = self._calculate_complexity_match(proposed_solution, preferences)
            quality_match = self._calculate_quality_match(proposed_solution, preferences)
            
            # 重み付き平均
            predicted_satisfaction = (
                style_match * 0.3 +
                complexity_match * 0.3 +
                quality_match * 0.4
            )
            
            # 信頼度による調整
            confidence = preferences['confidence']
            if confidence < 0.5:
                # 信頼度が低い場合は中性的な予測
                predicted_satisfaction = 0.5 + (predicted_satisfaction - 0.5) * confidence * 2
            
            return max(0.0, min(1.0, predicted_satisfaction))
            
        except Exception as e:
            logging.error(f"Error predicting FF satisfaction: {e}")
            return 0.5
    
    def _calculate_style_match(self, solution: Dict[str, Any], preferences: Dict[str, Any]) -> float:
        """スタイルマッチ度計算"""
        # 簡易実装：コード特徴から推定
        solution_features = solution.get('features', {})
        
        readability_score = solution_features.get('readability', 0.5)
        simplicity_score = solution_features.get('simplicity', 0.5)
        
        # 好みとのマッチ度計算
        style_preferences = preferences.get('code_style', {})
        avg_style_pref = sum(style_preferences.values()) / max(len(style_preferences), 1) if style_preferences else 0.7
        
        match_score = (readability_score + simplicity_score) / 2
        return abs(match_score - avg_style_pref) < 0.3 and match_score or avg_style_pref
    
    def _calculate_complexity_match(self, solution: Dict[str, Any], preferences: Dict[str, Any]) -> float:
        """複雑度マッチ度計算"""
        solution_complexity = solution.get('complexity_level', 0.5)
        preferred_complexity = preferences.get('complexity_level', 0.5)
        
        # 複雑度差の逆数でマッチ度計算
        complexity_diff = abs(solution_complexity - preferred_complexity)
        return max(0.0, 1.0 - complexity_diff * 2)
    
    def _calculate_quality_match(self, solution: Dict[str, Any], preferences: Dict[str, Any]) -> float:
        """品質マッチ度計算"""
        solution_quality = solution.get('quality_score', 0) / 100.0  # 0-1スケールに正規化
        error_tolerance = preferences.get('error_tolerance', 0.6)
        
        # 品質が期待値を上回る場合は高評価
        if solution_quality >= error_tolerance:
            return min(1.0, solution_quality + 0.1)
        else:
            return solution_quality * 0.8
    
    def get_learning_stats(self) -> Dict[str, Any]:
        """学習統計取得"""
        try:
            return {
                'total_interactions': self.interaction_count,
                'learning_active': self.learning_active,
                'last_analysis': self.last_analysis_time.isoformat(),
                'pattern_counts': {
                    name: len(getattr(pattern, 'patterns', {}))
                    for name, pattern in self.preference_patterns.items()
                },
                'storage_stats': {
                    'preference_cache_size': self.storage.preference_cache.size(),
                    'interaction_cache_size': self.storage.interaction_cache.size(),
                    'pattern_cache_size': self.storage.pattern_cache.size()
                },
                'confidence_levels': self._get_confidence_summary()
            }
        except Exception as e:
            logging.error(f"Error getting learning stats: {e}")
            return {'error': str(e)}
    
    def _get_confidence_summary(self) -> Dict[str, float]:
        """信頼度サマリー取得"""
        confidence_summary = {}
        
        for pattern_name, pattern in self.preference_patterns.items():
            if hasattr(pattern, 'confidence_scores') and pattern.confidence_scores:
                avg_confidence = sum(pattern.confidence_scores.values()) / len(pattern.confidence_scores)
                confidence_summary[pattern_name] = avg_confidence
            else:
                confidence_summary[pattern_name] = 0.0
        
        return confidence_summary
    
    def reset_learning_data(self, pattern_types: List[str] = None):
        """学習データリセット"""
        try:
            if pattern_types is None:
                # 全パターンリセット
                for pattern in self.preference_patterns.values():
                    if hasattr(pattern, 'patterns'):
                        pattern.patterns.clear()
                    if hasattr(pattern, 'preferences'):
                        pattern.preferences.clear()
                    if hasattr(pattern, 'trust_levels'):
                        pattern.trust_levels.clear()
                
                # ストレージクリア
                self.storage.preference_cache.clear()
                self.storage.interaction_cache.clear()
                self.storage.pattern_cache.clear()
                
                logging.info("All learning data reset")
            else:
                # 指定パターンのみリセット
                for pattern_type in pattern_types:
                    if pattern_type in self.preference_patterns:
                        pattern = self.preference_patterns[pattern_type]
                        if hasattr(pattern, 'patterns'):
                            pattern.patterns.clear()
                        if hasattr(pattern, 'preferences'):
                            pattern.preferences.clear()
                
                logging.info(f"Learning data reset for patterns: {pattern_types}")
                
        except Exception as e:
            logging.error(f"Error resetting learning data: {e}")
    
    def shutdown(self):
        """システムシャットダウン"""
        try:
            self.learning_active = False
            self.storage.stop_cleanup()
            logging.info("FF Preference Learner shutdown completed")
        except Exception as e:
            logging.error(f"Error during shutdown: {e}")

# ===================================================================
# テスト・デモンストレーション
# ===================================================================

def run_ff_preference_test():
    """FF好み学習システムテスト"""
    
    print("🧪 FF Preference Learner テスト開始（DD2改善版）")
    print("=" * 60)
    
    # システム初期化
    learner = FFPreferenceLearner()
    
    try:
        print("✅ システム初期化完了")
        
        # テストインタラクションデータ生成
        test_interactions = [
            InteractionData(
                timestamp=datetime.now(),
                ff_request="セキュアなファイル処理システムを作成してください",
                choices_made=["simple_implementation", "high_security"],
                satisfaction_score=0.9,
                efficiency_preference=0.8,
                quality_priority=0.95,
                automation_acceptance=0.7,
                context_type="file_operation",
                result_quality=98.0
            ),
            InteractionData(
                timestamp=datetime.now(),
                ff_request="データベース接続システムの実装",
                choices_made=["standard_approach", "error_handling"],
                satisfaction_score=0.85,
                efficiency_preference=0.9,
                quality_priority=0.8,
                automation_acceptance=0.8,
                context_type="database_integration",
                result_quality=96.0
            ),
            InteractionData(
                timestamp=datetime.now(),
                ff_request="API統合システムの開発",
                choices_made=["comprehensive_implementation", "detailed_logging"],
                satisfaction_score=0.75,
                efficiency_preference=0.6,
                quality_priority=0.9,
                automation_acceptance=0.9,
                context_type="api_integration",
                result_quality=97.0
            )
        ]
        
        # インタラクション観察
        print("\n📊 テストインタラクション処理中...")
        for i, interaction in enumerate(test_interactions):
            learner.observe_ff_interaction(interaction)
            print(f"   インタラクション {i+1}: {interaction.context_type} - 満足度 {interaction.satisfaction_score}")
        
        # 好み学習結果確認
        print("\n🧠 学習結果確認:")
        for context in ["file_operation", "database_integration", "api_integration"]:
            preferences = learner.get_ff_preferences(context)
            print(f"   {context}:")
            print(f"     複雑度好み: {preferences['complexity_level']:.2f}")
            print(f"     エラー許容度: {preferences['error_tolerance']:.2f}")
            print(f"     自動化受入: {preferences['automation_acceptance']:.2f}")
            print(f"     信頼度: {preferences['confidence']:.2f}")
        
        # 満足度予測テスト
        print("\n🔮 満足度予測テスト:")
        test_solution = {
            'features': {'readability': 0.9, 'simplicity': 0.8},
            'complexity_level': 0.6,
            'quality_score': 98
        }
        
        predicted_satisfaction = learner.predict_ff_satisfaction(test_solution, "file_operation")
        print(f"   予測満足度: {predicted_satisfaction:.2f}")
        
        # 学習統計表示
        print("\n📈 学習統計:")
        stats = learner.get_learning_stats()
        print(f"   総インタラクション数: {stats['total_interactions']}")
        print(f"   学習状態: {'アクティブ' if stats['learning_active'] else '停止'}")
        print(f"   キャッシュ使用状況:")
        for cache_name, size in stats['storage_stats'].items():
            print(f"     {cache_name}: {size}")
        
        # DD2改善テスト: メモリ最適化確認
        print("\n🧹 DD2改善機能テスト:")
        print(f"   メモリクリーンアップ: 実行中")
        learner.storage._perform_cleanup()
        print(f"   データ圧縮: 有効")
        
        # 非破壊テスト: 学習データリセット
        print("\n🔄 非破壊性テスト:")
        original_stats = learner.get_learning_stats()
        learner.reset_learning_data(['code_style'])
        reset_stats = learner.get_learning_stats()
        print(f"   部分リセット完了: code_style")
        print(f"   他データ保護: ✅")
        
        print("\n" + "=" * 60)
        print("✅ FF Preference Learner（DD2改善版）テスト完了!")
        print("🎯 DD2改善点適用:")
        print("   ✅ メモリ最適化（LRUCache + 圧縮）")
        print("   ✅ 定期クリーンアップ")
        print("   ✅ 収束保証（後続ファイルで実装）")
        
    except Exception as e:
        print(f"❌ テストエラー: {e}")
        import traceback
        traceback.print_exc()
    finally:
        learner.shutdown()

if __name__ == "__main__":
    # ログ設定
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    run_ff_preference_test()
