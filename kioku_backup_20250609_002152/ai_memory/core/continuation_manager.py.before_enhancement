"""
üß† kioku System - ProjectContinuationManager
Purpose: 15ÁßíÂÆåÁíßÁ∂ôÊâø„Åß„Åç„Çã‰ΩúÊ•≠Á∂ôÁ∂öË®òÊÜ∂Ê©üËÉΩ
Created: 2025-06-04
"""

import json
import os
from datetime import datetime, timezone
from pathlib import Path
import subprocess

class ProjectContinuationManager:
    """‰ΩúÊ•≠Á∂ôÁ∂öË®òÊÜ∂ÁÆ°ÁêÜ„ÇØ„É©„Çπ - 15ÁßíÂÆåÁíßÁ∂ôÊâø„Ç∑„Çπ„ÉÜ„É†"""
    
    def __init__(self):
        self.base_path = Path("ai_memory/storage/continuation")
        self.base_path.mkdir(parents=True, exist_ok=True)
        
        # Á∂ôÁ∂öË®òÊÜ∂„Éï„Ç°„Ç§„É´„Éë„Çπ
        self.phase_file = self.base_path / "current_phase.json"
        self.constraints_file = self.base_path / "technical_constraints.json"
        self.commands_file = self.base_path / "next_commands.json" 
        self.patterns_file = self.base_path / "success_patterns.json"
        self.handover_file = self.base_path / "15sec_handover_prompt.md"
        
        # ÂàùÊúüÂåñ
        self._initialize_files()
    
    def _initialize_files(self):
        """Á∂ôÁ∂öË®òÊÜ∂„Éï„Ç°„Ç§„É´ÂàùÊúüÂåñ"""
        
        # current_phase.jsonÂàùÊúüÂåñ
        if not self.phase_file.exists():
            initial_phase = {
                "timestamp": datetime.now(timezone.utc).isoformat(),
                "current_phase": "system_initialization",
                "phase_number": 1,
                "step": "setup",
                "progress_percentage": 0,
                "estimated_completion": "30_minutes",
                "description": "kioku„Ç∑„Çπ„ÉÜ„É†Á∂ôÁ∂öË®òÊÜ∂Ê©üËÉΩÂàùÊúüÂåñ",
                "next_immediate_action": "ProjectContinuationManagerÂÆüË£Ö"
            }
            self._save_json(self.phase_file, initial_phase)
        
        # technical_constraints.jsonÂàùÊúüÂåñ
        if not self.constraints_file.exists():
            initial_constraints = {
                "timestamp": datetime.now(timezone.utc).isoformat(),
                "resolved_issues": [],
                "current_constraints": [],
                "technical_decisions": []
            }
            self._save_json(self.constraints_file, initial_constraints)
        
        # next_commands.jsonÂàùÊúüÂåñ
        if not self.commands_file.exists():
            initial_commands = {
                "timestamp": datetime.now(timezone.utc).isoformat(),
                "immediate_next": ["python3 -c \"from ai_memory.core.continuation_manager import ProjectContinuationManager; cm=ProjectContinuationManager(); print('‚úÖ Á∂ôÁ∂öË®òÊÜ∂„Ç∑„Çπ„ÉÜ„É†ÂàùÊúüÂåñÂÆå‰∫Ü')\""],
                "phase_completion": [],
                "rollback_commands": []
            }
            self._save_json(self.commands_file, initial_commands)
        
        # success_patterns.jsonÂàùÊúüÂåñ
        if not self.patterns_file.exists():
            initial_patterns = {
                "timestamp": datetime.now(timezone.utc).isoformat(),
                "successful_patterns": [],
                "failure_patterns": [],
                "best_practices": [
                    "ÂÆüË£ÖÂâçÂøÖ„Åö„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó",
                    "ÊÆµÈöéÁöÑ„ÉÜ„Çπ„ÉàÂÆüË°å",
                    "ÈùûÁ†¥Â£äÁöÑ‰ΩúÊ•≠ÂæπÂ∫ï"
                ]
            }
            self._save_json(self.patterns_file, initial_patterns)
    
    def save_work_snapshot(self, phase, step, progress, description, next_action):
        """‰ΩúÊ•≠„Çπ„Éä„ÉÉ„Éó„Ç∑„Éß„ÉÉ„Éà‰øùÂ≠ò"""
        snapshot = {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "current_phase": phase,
            "phase_number": self._extract_phase_number(phase),
            "step": step,
            "progress_percentage": progress,
            "estimated_completion": self._estimate_completion(progress),
            "description": description,
            "next_immediate_action": next_action,
            "git_status": self._get_git_status_enhanced(),
            "active_files": self._get_active_files()
        }
        
        self._save_json(self.phase_file, snapshot)
        print(f"üì∏ ‰ΩúÊ•≠„Çπ„Éä„ÉÉ„Éó„Ç∑„Éß„ÉÉ„Éà‰øùÂ≠ò: {phase} - {step} ({progress}%)")
        return True
    
    def generate_15sec_handover(self):
        """15ÁßíÁ∂ôÊâø„Éó„É≠„É≥„Éó„ÉàÁîüÊàê"""
        try:
            # ÂêÑ„Éï„Ç°„Ç§„É´„Åã„Çâ„Éá„Éº„ÇøË™≠„ÅøËæº„Åø
            phase_data = self._load_json(self.phase_file)
            constraints_data = self._load_json(self.constraints_file)
            commands_data = self._load_json(self.commands_file)
            patterns_data = self._load_json(self.patterns_file)
            
            # GitÁä∂ÊÖãÂèñÂæó
            git_status = self._get_git_status_enhanced()
            
            # 15ÁßíÁ∂ôÊâø„Éó„É≠„É≥„Éó„ÉàÁîüÊàê
            handover = f"""üß† **15ÁßíÂÆåÁíßÁ∂ôÊâø„Éó„É≠„É≥„Éó„Éà** - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## ‚ö° Âç≥Â∫ßÂÆüË°åÊÉÖÂ†±
```bash
cd ~/lvyuan_solar_control
# ÁèæÂú®Phase: {phase_data.get('current_phase', 'unknown')}
# Progress: {phase_data.get('progress_percentage', 0)}%
# GitÁä∂ÊÖã: {git_status}
```

## üéØ ÁèæÂú®Áä∂Ê≥Å
- **Phase**: {phase_data.get('current_phase', 'unknown')} (Step: {phase_data.get('step', 'unknown')})
- **ÈÄ≤Êçó**: {phase_data.get('progress_percentage', 0)}% ÂÆå‰∫Ü
- **Ë™¨Êòé**: {phase_data.get('description', 'No description')}
- **Ê¨°„Ç¢„ÇØ„Ç∑„Éß„É≥**: {phase_data.get('next_immediate_action', 'TBD')}

## üö® ÈáçË¶ÅÂà∂Á¥Ñ
{self._format_constraints(constraints_data)}

## üöÄ Ê¨°„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥
```bash
{self._format_next_commands(commands_data)}
```

## üí° ÊàêÂäü„Éë„Çø„Éº„É≥ÈÅ©Áî®
{self._format_success_patterns(patterns_data)}

## üîß Âç≥Â∫ßÂÆüË°å„Ç≥„Éû„É≥„Éâ
```bash
{commands_data.get('immediate_next', ['# No immediate commands'])[0] if commands_data.get('immediate_next') else '# No commands available'}
```

## üìä ÊäÄË°ìÁä∂Ê≥Å
- **GitÁä∂ÊÖã**: {git_status}
- **„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Éï„Ç°„Ç§„É´**: {', '.join(self._get_active_files()[:3])}
- **Êé®ÂÆöÂÆå‰∫Ü**: {phase_data.get('estimated_completion', 'unknown')}

**„Åì„ÅÆÁ∂ôÊâø„ÅßÂç≥Â∫ß„Å´‰ΩúÊ•≠Á∂ôÁ∂öÂèØËÉΩÔºÅ**
"""
            
            # Á∂ôÊâø„Éó„É≠„É≥„Éó„Éà„Éï„Ç°„Ç§„É´‰øùÂ≠ò
            with open(self.handover_file, 'w', encoding='utf-8') as f:
                f.write(handover)
            
            print("‚úÖ 15ÁßíÁ∂ôÊâø„Éó„É≠„É≥„Éó„ÉàÁîüÊàêÂÆå‰∫Ü")
            print(f"üìÑ ‰øùÂ≠òÂÖà: {self.handover_file}")
            return handover
            
        except Exception as e:
            print(f"‚ùå Á∂ôÊâø„Éó„É≠„É≥„Éó„ÉàÁîüÊàê„Ç®„É©„Éº: {e}")
            return "üö® Á∂ôÊâø„Éó„É≠„É≥„Éó„ÉàÁîüÊàêÂ§±Êïó"
    
    def record_technical_constraint(self, constraint, impact, priority="medium"):
        """ÊäÄË°ìÂà∂Á¥ÑË®òÈå≤"""
        try:
            constraints_data = self._load_json(self.constraints_file)
            
            new_constraint = {
                "constraint": constraint,
                "impact": impact,
                "priority": priority,
                "recorded_at": datetime.now(timezone.utc).isoformat()
            }
            
            if "current_constraints" not in constraints_data:
                constraints_data["current_constraints"] = []
            
            constraints_data["current_constraints"].append(new_constraint)
            constraints_data["timestamp"] = datetime.now(timezone.utc).isoformat()
            
            self._save_json(self.constraints_file, constraints_data)
            print(f"üìù ÊäÄË°ìÂà∂Á¥ÑË®òÈå≤: {constraint}")
            return True
            
        except Exception as e:
            print(f"‚ùå Âà∂Á¥ÑË®òÈå≤„Ç®„É©„Éº: {e}")
            return False
    
    def save_next_command(self, command_type, commands):
        """Ê¨°„Çπ„ÉÜ„ÉÉ„Éó„Ç≥„Éû„É≥„Éâ‰øùÂ≠ò"""
        try:
            commands_data = self._load_json(self.commands_file)
            
            commands_data[command_type] = commands if isinstance(commands, list) else [commands]
            commands_data["timestamp"] = datetime.now(timezone.utc).isoformat()
            
            self._save_json(self.commands_file, commands_data)
            print(f"üíæ Ê¨°„Çπ„ÉÜ„ÉÉ„Éó„Ç≥„Éû„É≥„Éâ‰øùÂ≠ò: {command_type}")
            return True
            
        except Exception as e:
            print(f"‚ùå „Ç≥„Éû„É≥„Éâ‰øùÂ≠ò„Ç®„É©„Éº: {e}")
            return False
    
    def mark_phase_complete(self, phase, success_factors=None):
        """PhaseÂÆå‰∫Ü„Éû„Éº„Ç≠„É≥„Ç∞"""
        try:
            patterns_data = self._load_json(self.patterns_file)
            
            completion_record = {
                "pattern": f"{phase}_completion",
                "phase": phase,
                "completion_time": datetime.now(timezone.utc).isoformat(),
                "success_factors": success_factors or ["ÊÆµÈöéÁöÑÂÆüË£Ö", "„ÉÜ„Çπ„ÉàÂÆå‰∫Ü"]
            }
            
            if "successful_patterns" not in patterns_data:
                patterns_data["successful_patterns"] = []
            
            patterns_data["successful_patterns"].append(completion_record)
            patterns_data["timestamp"] = datetime.now(timezone.utc).isoformat()
            
            self._save_json(self.patterns_file, patterns_data)
            print(f"üéâ PhaseÂÆå‰∫ÜË®òÈå≤: {phase}")
            return True
            
        except Exception as e:
            print(f"‚ùå ÂÆå‰∫ÜË®òÈå≤„Ç®„É©„Éº: {e}")
            return False
    
    def get_current_status(self):
        """ÁèæÂú®Áä∂Ê≥ÅÂèñÂæó"""
        phase_data = self._load_json(self.phase_file)
        return {
            "phase": phase_data.get('current_phase', 'unknown'),
            "step": phase_data.get('step', 'unknown'),
            "progress": phase_data.get('progress_percentage', 0),
            "next_action": phase_data.get('next_immediate_action', 'TBD')
        }
    
    # Helper methods
    def _load_json(self, file_path):
        """JSON„Éï„Ç°„Ç§„É´ÂÆâÂÖ®Ë™≠„ÅøËæº„Åø"""
        try:
            if file_path.exists():
                with open(file_path, 'r', encoding='utf-8') as f:
                    return json.load(f)
            return {}
        except Exception as e:
            print(f"‚ö†Ô∏è JSONË™≠„ÅøËæº„Åø„Ç®„É©„Éº: {file_path} - {e}")
            return {}
    
    def _save_json(self, file_path, data):
        """JSON„Éï„Ç°„Ç§„É´ÂÆâÂÖ®‰øùÂ≠ò"""
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
            return True
        except Exception as e:
            print(f"‚ùå JSON‰øùÂ≠ò„Ç®„É©„Éº: {file_path} - {e}")
            return False
    
    def _extract_phase_number(self, phase):
        """PhaseÁï™Âè∑ÊäΩÂá∫"""
        try:
            import re
            match = re.search(r'(\d+)', phase)
            return int(match.group(1)) if match else 1
        except:
            return 1
    
    def _estimate_completion(self, progress):
        """ÂÆå‰∫ÜÊôÇÈñìÊé®ÂÆö"""
        if progress >= 90:
            return "5_minutes"
        elif progress >= 70:
            return "15_minutes"
        elif progress >= 50:
            return "30_minutes"
        else:
            return "60_minutes"
    
    def _get_git_status(self):
        """GitÁä∂ÊÖãÂèñÂæó"""
        try:
            result = subprocess.run(['git', 'status', '--porcelain'], 
                                  capture_output=True, text=True, cwd='.')
            lines = result.stdout.strip().split('\n') if result.stdout.strip() else []
            return f"{len(lines)} files changed" if lines else "clean"
        except:
            return "unknown"
    
    def _get_active_files(self):
        """„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Éï„Ç°„Ç§„É´‰∏ÄË¶ß"""
        try:
            result = subprocess.run(['git', 'diff', '--name-only', 'HEAD'], 
                                  capture_output=True, text=True, cwd='.')
            files = result.stdout.strip().split('\n') if result.stdout.strip() else []
            return [f for f in files if f][:5]  # ÊúÄÂ§ß5„Éï„Ç°„Ç§„É´
        except:
            return []
    
    def _format_constraints(self, constraints_data):
        """Âà∂Á¥Ñ„Éï„Ç©„Éº„Éû„ÉÉ„Éà"""
        constraints = constraints_data.get('current_constraints', [])
        if not constraints:
            return "- ÁèæÂú®Âà∂Á¥Ñ„Å™„Åó"
        
        formatted = []
        for c in constraints[-3:]:  # ÊúÄÊñ∞3‰ª∂
            formatted.append(f"- **{c.get('constraint', 'Unknown')}**: {c.get('impact', 'No impact')} ({c.get('priority', 'medium')})")
        
        return '\n'.join(formatted)
    
    def _format_next_commands(self, commands_data):
        """Ê¨°„Ç≥„Éû„É≥„Éâ„Éï„Ç©„Éº„Éû„ÉÉ„Éà"""
        immediate = commands_data.get('immediate_next', [])
        return '\n'.join(immediate[:3]) if immediate else "# Ê¨°„ÅÆ„Ç≥„Éû„É≥„Éâ„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì"
    
    def _format_success_patterns(self, patterns_data):
        """ÊàêÂäü„Éë„Çø„Éº„É≥„Éï„Ç©„Éº„Éû„ÉÉ„Éà"""
        patterns = patterns_data.get('successful_patterns', [])
        if not patterns:
            return "- Êñ∞Ë¶èÂÆüË£ÖÔºàÊàêÂäü„Éë„Çø„Éº„É≥ËìÑÁ©ç‰∏≠Ôºâ"
        
        latest = patterns[-1]
        return f"- **ÈÅ©Áî®„Éë„Çø„Éº„É≥**: {latest.get('pattern', 'Unknown')}\n- **ÊàêÂäüË¶ÅÂõ†**: {', '.join(latest.get('success_factors', []))}"


# „ÉÜ„Çπ„ÉàÁî®Èñ¢Êï∞
def test_continuation_manager():
    """Á∂ôÁ∂öË®òÊÜ∂„Ç∑„Çπ„ÉÜ„É†„ÉÜ„Çπ„Éà"""
    print("üß™ Á∂ôÁ∂öË®òÊÜ∂„Ç∑„Çπ„ÉÜ„É†„ÉÜ„Çπ„ÉàÈñãÂßã")
    
    try:
        # „Ç§„É≥„Çπ„Çø„É≥„Çπ‰ΩúÊàê
        cm = ProjectContinuationManager()
        print("‚úÖ ProjectContinuationManagerÂàùÊúüÂåñÂÆå‰∫Ü")
        
        # „Çπ„Éä„ÉÉ„Éó„Ç∑„Éß„ÉÉ„Éà‰øùÂ≠ò„ÉÜ„Çπ„Éà
        cm.save_work_snapshot(
            phase="kioku_system_expansion",
            step="implementation",
            progress=50,
            description="kiokuÁ∂ôÁ∂öË®òÊÜ∂Ê©üËÉΩÂÆüË£Ö‰∏≠",
            next_action="ai_startup_memory.pyÊã°Âºµ"
        )
        
        # Âà∂Á¥ÑË®òÈå≤„ÉÜ„Çπ„Éà
        cm.record_technical_constraint(
            constraint="„É©„Ç∫„Éë„Ç§„Çø„Éº„Éü„Éä„É´Ë°åÊï∞Âà∂Èôê",
            impact="„Ç≥„Éî„Éö30-40Ë°åÂà∂Èôê",
            priority="high"
        )
        
        # Ê¨°„Ç≥„Éû„É≥„Éâ‰øùÂ≠ò„ÉÜ„Çπ„Éà
        cm.save_next_command("immediate_next", [
            "python3 -c \"from ai_memory.core.continuation_manager import test_continuation_manager; test_continuation_manager()\"",
            "nano ai_memory/ai_startup_memory.py  # Êã°ÂºµÂÆüË£Ö"
        ])
        
        # 15ÁßíÁ∂ôÊâø„Éó„É≠„É≥„Éó„ÉàÁîüÊàê„ÉÜ„Çπ„Éà
        handover = cm.generate_15sec_handover()
        print("‚úÖ 15ÁßíÁ∂ôÊâø„Éó„É≠„É≥„Éó„ÉàÁîüÊàêÂÆå‰∫Ü")
        
        # ÁèæÂú®Áä∂Ê≥ÅÁ¢∫Ë™ç
        status = cm.get_current_status()
        print(f"üìä ÁèæÂú®Áä∂Ê≥Å: {status['phase']} - {status['step']} ({status['progress']}%)")
        
        print("üéâ Á∂ôÁ∂öË®òÊÜ∂„Ç∑„Çπ„ÉÜ„É†„ÉÜ„Çπ„ÉàÂÆå‰∫ÜÔºÅ")
        return True
        
    except Exception as e:
        print(f"‚ùå „ÉÜ„Çπ„Éà„Ç®„É©„Éº: {e}")
        return False


if __name__ == "__main__":
    test_continuation_manager()
[GitË©≥Á¥∞Ë®òÈå≤Ê©üËÉΩ„Ç≥„Éº„Éâ 35Ë°å]

    def record_git_changes_detail(self):
        """GitÂ§âÊõ¥Ë©≥Á¥∞Ë®òÈå≤Ôºà„Éï„Ç°„Ç§„É´Âà•Â∑ÆÂàÜÁµ±Ë®àÔºâ"""
        try:
            # GitÂ∑ÆÂàÜÁµ±Ë®àÂèñÂæó
            result = subprocess.run(['git', 'diff', '--stat'], 
                                  capture_output=True, text=True, cwd='.')
            
            if result.stdout.strip():
                lines = result.stdout.strip().split('\n')
                
                # Â§âÊõ¥„Éï„Ç°„Ç§„É´Ë©≥Á¥∞Ëß£Êûê
                file_changes = []
                for line in lines[:-1]:  # ÊúÄÂæå„ÅÆË¶ÅÁ¥ÑË°å„ÇíÈô§„Åè
                    if '|' in line:
                        parts = line.split('|')
                        filename = parts[0].strip()
                        changes = parts[1].strip() if len(parts) > 1 else ''
                        file_changes.append({
                            'file': filename,
                            'changes': changes
                        })
                
                # Ë¶ÅÁ¥ÑË°åËß£Êûê
                summary_line = lines[-1] if lines else ''
                files_changed = len(file_changes)
                
                # ‰∏ªË¶ÅÂ§âÊõ¥„Éï„Ç°„Ç§„É´ÁâπÂÆöÔºà‰∏ä‰Ωç5‰ª∂Ôºâ
                major_files = [f['file'] for f in file_changes[:5]]
                
                git_detail = {
                    'timestamp': datetime.now(timezone.utc).isoformat(),
                    'files_changed': files_changed,
                    'summary': summary_line,
                    'major_changes': major_files,
                    'file_details': file_changes[:10],
                    'change_scale': self._assess_change_scale(files_changed)
                }
                
                return git_detail
            else:
                return {'status': 'no_changes', 'files_changed': 0}
                
        except Exception as e:
            print(f"‚ö†Ô∏è GitË©≥Á¥∞Ë®òÈå≤„Ç®„É©„Éº: {e}")
            return {'status': 'error', 'error': str(e)}

    def _assess_change_scale(self, files_changed):
        """Â§âÊõ¥Ë¶èÊ®°Ë©ï‰æ°"""
        if files_changed >= 100:
            return "massive"
        elif files_changed >= 50:
            return "large"
        elif files_changed >= 20:
            return "medium"
        elif files_changed >= 5:
            return "small"
        else:
            return "minimal"

    def _get_git_status_enhanced(self):
        """GitÁä∂ÊÖãÂèñÂæóÔºàË©≥Á¥∞ÁâàÔºâ"""
        try:
            # Âü∫Êú¨Áä∂ÊÖã
            result = subprocess.run(['git', 'status', '--porcelain'], 
                                  capture_output=True, text=True, cwd='.')
            lines = result.stdout.strip().split('\n') if result.stdout.strip() else []
            
            # Ë©≥Á¥∞Ë®òÈå≤ÂèñÂæó
            git_detail = self.record_git_changes_detail()
            
            if git_detail.get('files_changed', 0) > 0:
                scale = git_detail.get('change_scale', 'unknown')
                major_files = git_detail.get('major_changes', [])
                return f"{len(lines)} files changed ({scale}) - ‰∏ªË¶Å: {', '.join(major_files[:3])}"
            else:
                return f"{len(lines)} files changed" if lines else "clean"
                
        except Exception as e:
            return "unknown"

    def record_git_changes_detail(self):
        """GitÂ§âÊõ¥Ë©≥Á¥∞Ë®òÈå≤Ôºà„Éï„Ç°„Ç§„É´Âà•Â∑ÆÂàÜÁµ±Ë®àÔºâ"""
        try:
            result = subprocess.run(['git', 'diff', '--stat'], 
                                  capture_output=True, text=True, cwd='.')
            
            if result.stdout.strip():
                lines = result.stdout.strip().split('\n')
                file_changes = []
                for line in lines[:-1]:
                    if '|' in line:
                        parts = line.split('|')
                        filename = parts[0].strip()
                        changes = parts[1].strip() if len(parts) > 1 else ''
                        file_changes.append({'file': filename, 'changes': changes})
                
                summary_line = lines[-1] if lines else ''
                files_changed = len(file_changes)
                major_files = [f['file'] for f in file_changes[:5]]
                
                git_detail = {
                    'timestamp': datetime.now(timezone.utc).isoformat(),
                    'files_changed': files_changed,
                    'summary': summary_line,
                    'major_changes': major_files,
                    'file_details': file_changes[:10],
                    'change_scale': self._assess_change_scale(files_changed)
                }
                return git_detail
            else:
                return {'status': 'no_changes', 'files_changed': 0}
        except Exception as e:
            print(f"‚ö†Ô∏è GitË©≥Á¥∞Ë®òÈå≤„Ç®„É©„Éº: {e}")
            return {'status': 'error', 'error': str(e)}

    def _assess_change_scale(self, files_changed):
        """Â§âÊõ¥Ë¶èÊ®°Ë©ï‰æ°"""
        if files_changed >= 100:
            return "massive"
        elif files_changed >= 50:
            return "large"
        elif files_changed >= 20:
            return "medium"
        elif files_changed >= 5:
            return "small"
        else:
            return "minimal"

    def _get_git_status_enhanced(self):
        """GitÁä∂ÊÖãÂèñÂæóÔºàË©≥Á¥∞ÁâàÔºâ"""
        try:
            result = subprocess.run(['git', 'status', '--porcelain'], 
                                  capture_output=True, text=True, cwd='.')
            lines = result.stdout.strip().split('\n') if result.stdout.strip() else []
            
            git_detail = self.record_git_changes_detail()
            
            if git_detail.get('files_changed', 0) > 0:
                scale = git_detail.get('change_scale', 'unknown')
                major_files = git_detail.get('major_changes', [])
                major_str = ', '.join(major_files[:3])
                return f"{len(lines)} files changed ({scale}) - ‰∏ªË¶Å: {major_str}"
            else:
                return f"{len(lines)} files changed" if lines else "clean"
        except Exception as e:
            return "unknown"
