#!/usr/bin/env python3
"""LVYUAN ã‚¤ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿åé›†ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆæ”¹è‰¯ç‰ˆï¼‰"""

import os
import time
import json
import logging
import socket
import subprocess
from datetime import datetime
from pysolarmanv5 import PySolarmanV5


class LVYUANCollector:
    def __init__(self, settings_file=None):
        # è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
        if settings_file is None:
            self.settings_file = os.path.join(os.path.dirname(
                os.path.abspath(__file__)), 'settings.json')
        else:
            self.settings_file = settings_file

        # è¨­å®šã®èª­ã¿è¾¼ã¿
        self.settings = self._load_settings()

        # ãƒ‡ãƒ¼ã‚¿ä¿å­˜ç”¨ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
        self.data_dir = os.path.join(
            os.path.dirname(os.path.abspath(__file__)), 'data')
        os.makedirs(self.data_dir, exist_ok=True)

        # ãƒ­ã‚¬ãƒ¼è¨­å®š
        self.logger = logging.getLogger("lvyuan_collector")
        self._setup_logging()

    def _setup_logging(self):
        """ãƒ­ã‚®ãƒ³ã‚°è¨­å®š"""
        log_dir = os.path.join(os.path.dirname(
            os.path.abspath(__file__)), 'logs')
        os.makedirs(log_dir, exist_ok=True)

        log_file = os.path.join(
            log_dir, f'collector_{datetime.now().strftime("%Y%m%d")}.log')

        file_handler = logging.FileHandler(log_file)
        file_handler.setLevel(logging.INFO)

        console_handler = logging.StreamHandler()
        console_handler.setLevel(logging.INFO)

        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        file_handler.setFormatter(formatter)
        console_handler.setFormatter(formatter)

        self.logger.addHandler(file_handler)
        self.logger.addHandler(console_handler)
        self.logger.setLevel(logging.INFO)

    def _load_settings(self):
        """è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿"""
        try:
            if os.path.exists(self.settings_file):
                with open(self.settings_file, 'r') as f:
                    return json.load(f)
            else:
                # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’ä½œæˆ
                default_settings = {
                    "inverter": {
                        "ip": "192.168.0.202",  # æœ€å¾Œã«æ¥ç¶šã«æˆåŠŸã—ãŸIPã‚¢ãƒ‰ãƒ¬ã‚¹
                        "serial": 3528830226,
                        "mac": "D4:27:87:16:7A:F8",
                        "port": 8899,
                        "mb_slave_id": 1
                    },
                    "network": {
                        "subnet": "192.168.0.0/24",
                        "last_check": "2025-05-02T02:00:00"
                    },
                    "monitoring": {
                        "interval_minutes": 15,
                        "key_registers": [
                            {"address": "0x0100", "name": "ãƒãƒƒãƒ†ãƒªãƒ¼SOC",
                                "unit": "%", "factor": 1, "emoji": "ğŸ”‹"},
                            {"address": "0x0101", "name": "ãƒãƒƒãƒ†ãƒªãƒ¼é›»åœ§",
                                "unit": "V", "factor": 0.1, "emoji": "âš¡"},
                            {"address": "0x0102", "name": "ãƒãƒƒãƒ†ãƒªãƒ¼é›»æµ",
                                "unit": "A", "factor": 0.1, "emoji": "ğŸ”Œ"},
                            {"address": "0x020E", "name": "æ©Ÿå™¨çŠ¶æ…‹",
                                "unit": "", "factor": 1, "emoji": "ğŸ“Š"},
                            {"address": "0xE012", "name": "ãƒ–ãƒ¼ã‚¹ãƒˆå……é›»æ™‚é–“",
                                "unit": "åˆ†", "factor": 1, "emoji": "â±ï¸"}
                        ]
                    }
                }

                # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã‚’ä¿å­˜
                with open(self.settings_file, 'w') as f:
                    json.dump(default_settings, f, indent=2)

                return default_settings
        except Exception as e:
            self.logger.error(f"è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")
            return {}

    def _save_settings(self):
        """è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®ä¿å­˜"""
        try:
            with open(self.settings_file, 'w') as f:
                json.dump(self.settings, f, indent=2)
            self.logger.debug("è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜ã—ã¾ã—ãŸ")
        except Exception as e:
            self.logger.error(f"è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}")

    def find_inverter_ip(self):
        """ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¹ã‚­ãƒ£ãƒ³ã§ã‚¤ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ã®IPã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ç‰¹å®š"""
        self.logger.info("ã‚¤ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ã®IPã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æ¤œç´¢ä¸­...")

        # ç¾åœ¨ã®IPã‚¢ãƒ‰ãƒ¬ã‚¹ã«æ¥ç¶šã§ãã‚‹ã‹ç¢ºèª
        current_ip = self.settings["inverter"]["ip"]
        if self._check_inverter_connection(current_ip):
            self.logger.info(f"ç¾åœ¨ã®IPã‚¢ãƒ‰ãƒ¬ã‚¹ ({current_ip}) ã«æ¥ç¶šã§ãã¾ã™")
            return current_ip, False  # IPã‚¢ãƒ‰ãƒ¬ã‚¹å¤‰æ›´ãªã—

        # MACã‚¢ãƒ‰ãƒ¬ã‚¹
        mac_address = self.settings["inverter"]["mac"].replace(":", "-")

        # ã‚¹ã‚­ãƒ£ãƒ³å¯¾è±¡ã®ã‚µãƒ–ãƒãƒƒãƒˆ
        subnet = self.settings["network"]["subnet"]

        # nmapã‚’ä½¿ç”¨ã—ã¦ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¹ã‚­ãƒ£ãƒ³
        try:
            self.logger.info(f"ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¹ã‚­ãƒ£ãƒ³å®Ÿè¡Œä¸­... ({subnet})")

            # pingã‚¹ã‚­ãƒ£ãƒ³
            cmd = ["sudo", "nmap", "-sP", subnet]
            subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

            # arpãƒ†ãƒ¼ãƒ–ãƒ«ã‹ã‚‰MACã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æ¤œç´¢
            cmd = ["arp", "-a"]
            result = subprocess.run(
                cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

            # å‡ºåŠ›ã‹ã‚‰MACã‚¢ãƒ‰ãƒ¬ã‚¹ã¨IPã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æŠ½å‡º
            for line in result.stdout.splitlines():
                if mac_address.lower() in line.lower():
                    parts = line.split()
                    for part in parts:
                        if part.count('.') == 3:  # IPã‚¢ãƒ‰ãƒ¬ã‚¹ã®å½¢å¼
                            # æ‹¬å¼§ã‚’å‰Šé™¤
                            ip = part.strip('()')

                            # IPã‚¢ãƒ‰ãƒ¬ã‚¹ã¨æ¥ç¶šç¢ºèª
                            if self._check_inverter_connection(ip):
                                # IPã‚¢ãƒ‰ãƒ¬ã‚¹ãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆ
                                if ip != current_ip:
                                    self.logger.info(
                                        f"ã‚¤ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ã®IPã‚¢ãƒ‰ãƒ¬ã‚¹ãŒå¤‰æ›´ã•ã‚Œã¾ã—ãŸ: {current_ip} â†’ {ip}")
                                    self.settings["inverter"]["ip"] = ip
                                    self._save_settings()
                                    return ip, True  # IPã‚¢ãƒ‰ãƒ¬ã‚¹å¤‰æ›´ã‚ã‚Š
                                else:
                                    return ip, False  # IPã‚¢ãƒ‰ãƒ¬ã‚¹å¤‰æ›´ãªã—

            self.logger.warning(f"ã‚¤ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ã®MACã‚¢ãƒ‰ãƒ¬ã‚¹ ({mac_address}) ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")
            return None, False

        except Exception as e:
            self.logger.error(f"ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¹ã‚­ãƒ£ãƒ³ã‚¨ãƒ©ãƒ¼: {e}")
            return None, False

    def _check_inverter_connection(self, ip):
        """ã‚¤ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ã¸ã®æ¥ç¶šç¢ºèª"""
        try:
            # ã‚½ã‚±ãƒƒãƒˆæ¥ç¶šãƒ†ã‚¹ãƒˆ
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(2)
            result = s.connect_ex((ip, self.settings["inverter"]["port"]))
            s.close()

            if result == 0:
                # Modbusæ¥ç¶šãƒ†ã‚¹ãƒˆ
                try:
                    modbus = PySolarmanV5(
                        address=ip,
                        serial=self.settings["inverter"]["serial"],
                        port=self.settings["inverter"]["port"],
                        mb_slave_id=self.settings["inverter"]["mb_slave_id"],
                        verbose=False,
                        socket_timeout=5
                    )

                    # ãƒãƒƒãƒ†ãƒªãƒ¼SOCã‚’èª­ã¿å–ã‚Šè©¦è¡Œ
                    modbus.read_holding_registers(0x0100, 1)
                    return True
                except Exception as e:
                    self.logger.debug(f"Modbusæ¥ç¶šã‚¨ãƒ©ãƒ¼ ({ip}): {e}")
                    return False
            else:
                self.logger.debug(f"ã‚½ã‚±ãƒƒãƒˆæ¥ç¶šå¤±æ•— ({ip}): {result}")
                return False

        except Exception as e:
            self.logger.debug(f"æ¥ç¶šç¢ºèªã‚¨ãƒ©ãƒ¼ ({ip}): {e}")
            return False

    def collect_data(self):
        """ã‚¤ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’åé›†"""
        # IPã‚¢ãƒ‰ãƒ¬ã‚¹ç¢ºèª
        ip, ip_changed = self.find_inverter_ip()

        if ip is None:
            self.logger.error("ã‚¤ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ã®IPã‚¢ãƒ‰ãƒ¬ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            return None, ip_changed

        try:
            # Modbusæ¥ç¶š
            modbus = PySolarmanV5(
                address=ip,
                serial=self.settings["inverter"]["serial"],
                port=self.settings["inverter"]["port"],
                mb_slave_id=self.settings["inverter"]["mb_slave_id"],
                verbose=False,
                socket_timeout=10
            )

            # ãƒ‡ãƒ¼ã‚¿åé›†
            data = {
                "timestamp": time.time(),
                "datetime": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "ip_address": ip,
                "parameters": {}
            }

            # ä¸»è¦ãƒ¬ã‚¸ã‚¹ã‚¿ã®èª­ã¿å–ã‚Š
            for register_info in self.settings["monitoring"]["key_registers"]:
                try:
                    # ãƒ¬ã‚¸ã‚¹ã‚¿ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’16é€²æ•°ã‹ã‚‰æ•´æ•°ã«å¤‰æ›
                    address = int(register_info["address"], 16)

                    # èª­ã¿å–ã‚Š
                    raw_value = modbus.read_holding_registers(address, 1)[0]

                    # ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
                    scaled_value = raw_value * register_info["factor"]

                    # ç‰¹æ®Šãªå‡¦ç†ï¼ˆæ©Ÿå™¨çŠ¶æ…‹ãªã©ï¼‰
                    if address == 0x020E:
                        # æ©Ÿå™¨çŠ¶æ…‹ã®å ´åˆ
                        state_desc = {
                            0: "èµ·å‹•ä¸­",
                            1: "å¾…æ©Ÿä¸­",
                            2: "é‹è»¢ä¸­",
                            3: "ã‚½ãƒ•ãƒˆã‚¹ã‚¿ãƒ¼ãƒˆ",
                            4: "ã‚°ãƒªãƒƒãƒ‰å‡ºåŠ›",
                            5: "ã‚ªãƒ•ã‚°ãƒªãƒƒãƒ‰",
                            6: "ç³»çµ±å‡ºåŠ›",
                            7: "ç³»çµ±å´å‡ºåŠ›",
                            8: "ã‚¢ãƒ©ãƒ¼ãƒ ",
                            9: "æ®‹ã‚Š",
                            10: "ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³",
                            11: "æ•…éšœ"
                        }
                        formatted_value = state_desc.get(
                            raw_value, f"ä¸æ˜({raw_value})")
                    else:
                        # é€šå¸¸ã®æ•°å€¤
                        if register_info["factor"] == 1:
                            formatted_value = str(int(scaled_value))
                        else:
                            formatted_value = f"{scaled_value:.1f}"

                    # ãƒ‡ãƒ¼ã‚¿æ ¼ç´
                    data["parameters"][register_info["address"]] = {
                        "name": register_info["name"],
                        "raw_value": raw_value,
                        "value": scaled_value,
                        "formatted_value": formatted_value,
                        "unit": register_info["unit"],
                        "emoji": register_info["emoji"]
                    }

                except Exception as e:
                    self.logger.error(
                        f"ãƒ¬ã‚¸ã‚¹ã‚¿ {register_info['address']} ({register_info['name']}) ã®èª­ã¿å–ã‚Šã‚¨ãƒ©ãƒ¼: {e}")

            # ãƒ‡ãƒã‚¤ã‚¹IDã¨è£½å“æƒ…å ±ã‚’å–å¾—
            try:
                # è£½å“ãƒ¢ãƒ‡ãƒ«
                model_code = modbus.read_holding_registers(0x0018, 1)[0]
                data["device_info"] = {"model_code": model_code}

                # ã‚·ãƒªã‚¢ãƒ«ç•ªå·ï¼ˆASCIIãƒ‡ãƒ¼ã‚¿ï¼‰
                try:
                    ascii_regs = modbus.read_holding_registers(0x0021, 40)
                    sn_string = ""
                    for reg in ascii_regs:
                        if reg > 0:
                            high_byte = (reg >> 8) & 0xFF
                            low_byte = reg & 0xFF
                            if high_byte > 0:
                                sn_string += chr(high_byte)
                            if low_byte > 0:
                                sn_string += chr(low_byte)

                    if sn_string:
                        data["device_info"]["serial_string"] = sn_string.strip()
                except Exception as e:
                    self.logger.debug(f"ã‚·ãƒªã‚¢ãƒ«ç•ªå·æ–‡å­—åˆ—ã®èª­ã¿å–ã‚Šã‚¨ãƒ©ãƒ¼: {e}")
            except Exception as e:
                self.logger.debug(f"ãƒ‡ãƒã‚¤ã‚¹æƒ…å ±ã®èª­ã¿å–ã‚Šã‚¨ãƒ©ãƒ¼: {e}")

            # çµæœã‚’ä¿å­˜
            self._save_data(data)

            self.logger.info(
                f"ãƒ‡ãƒ¼ã‚¿åé›†æˆåŠŸ: {len(data['parameters'])}ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼, ã‚¤ãƒ³ãƒãƒ¼ã‚¿ãƒ¼IP: {ip}")
            return data, ip_changed

        except Exception as e:
            self.logger.error(f"ãƒ‡ãƒ¼ã‚¿åé›†ã‚¨ãƒ©ãƒ¼: {e}")
            return None, ip_changed

    def _save_data(self, data):
        """åé›†ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’JSONãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜"""
        if data is None:
            return

        # æ—¥ä»˜ã”ã¨ã®ãƒ•ã‚¡ã‚¤ãƒ«å
        today = datetime.now().strftime("%Y%m%d")
        filename = os.path.join(self.data_dir, f"data_{today}.json")

        try:
            # æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿
            existing_data = []
            if os.path.exists(filename):
                try:
                    with open(filename, 'r') as f:
                        existing_data = json.load(f)
                except json.JSONDecodeError:
                    self.logger.warning(
                        f"æ—¢å­˜ã®JSONãƒ•ã‚¡ã‚¤ãƒ« {filename} ãŒå£Šã‚Œã¦ã„ã¾ã™ã€‚æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ã¾ã™ã€‚")

            # æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã®è¿½åŠ 
            existing_data.append(data)

            # ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®æ›¸ãè¾¼ã¿
            with open(filename, 'w') as f:
                json.dump(existing_data, f, indent=2)

            self.logger.debug(f"ãƒ‡ãƒ¼ã‚¿ã‚’ {filename} ã«ä¿å­˜ã—ã¾ã—ãŸ")
        except Exception as e:
            self.logger.error(f"ãƒ‡ãƒ¼ã‚¿ä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}")


# ãƒ¡ã‚¤ãƒ³å‡¦ç†ï¼ˆã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å®Ÿè¡Œç”¨ï¼‰
if __name__ == "__main__":
    import argparse

    # ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³å¼•æ•°ã®è§£æ
    parser = argparse.ArgumentParser(description='LVYUANã‚¤ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿åé›†')
    parser.add_argument('--scan', action='store_true',
                        help='ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¹ã‚­ãƒ£ãƒ³ã§ã‚¤ãƒ³ãƒãƒ¼ã‚¿ãƒ¼IPã‚’æ¤œç´¢')
    parser.add_argument('--collect', action='store_true', help='ãƒ‡ãƒ¼ã‚¿åé›†ã‚’å®Ÿè¡Œ')
    parser.add_argument('--settings', help='è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹')

    args = parser.parse_args()

    # ã‚³ãƒ¬ã‚¯ã‚¿ãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ä½œæˆ
    collector = LVYUANCollector(args.settings)

    # IPã‚¢ãƒ‰ãƒ¬ã‚¹ã‚¹ã‚­ãƒ£ãƒ³
    if args.scan:
        ip, changed = collector.find_inverter_ip()
        if ip:
            print(f"ã‚¤ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ã®IPã‚¢ãƒ‰ãƒ¬ã‚¹: {ip}")
            if changed:
                print("â€» IPã‚¢ãƒ‰ãƒ¬ã‚¹ãŒå¤‰æ›´ã•ã‚Œã¾ã—ãŸ")
        else:
            print("ã‚¤ãƒ³ãƒãƒ¼ã‚¿ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ")

    # ãƒ‡ãƒ¼ã‚¿åé›†
    if args.collect:
        data, ip_changed = collector.collect_data()
        if data:
            print(f"ãƒ‡ãƒ¼ã‚¿åé›†æˆåŠŸ: {len(data['parameters'])}ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼")

            # ä¸»è¦ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®è¡¨ç¤º
            print("\n==== ä¸»è¦ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ ====")
            for address, param in data["parameters"].items():
                print(
                    f"{param['emoji']} {param['name']}: {param['formatted_value']}{param['unit']}")
        else:
            print("ãƒ‡ãƒ¼ã‚¿åé›†å¤±æ•—")

    # å¼•æ•°ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ãƒ˜ãƒ«ãƒ—ã‚’è¡¨ç¤º
    if not (args.scan or args.collect):
        parser.print_help()
